<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Agent Building with LangChain</title>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #1e40af;
            --accent: #3b82f6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --light: #f8fafc;
            --card: #ffffff;
            --text: #0f172a;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --code-bg: #0d1117;
            --code-text: #c9d1d9;
            --code-keyword: #ff7b72;
            --code-string: #a5d6ff;
            --code-comment: #8b949e;
            --code-function: #d2a8ff;
            --code-number: #79c0ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--light);
            color: var(--text);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--dark) 0%, var(--secondary) 100%);
            color: white;
            padding: 2rem 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }
        
        header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        
        header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .section {
            margin: 3rem 0;
        }
        
        .section-title {
            font-size: 2.2rem;
            color: var(--primary);
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--accent);
        }
        
        .card {
            background-color: var(--card);
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            padding: 2rem;
            margin-bottom: 2rem;
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .component-title {
            font-size: 1.8rem;
            color: var(--secondary);
            margin-bottom: 1.2rem;
            display: flex;
            align-items: center;
        }
        
        .component-title .icon {
            background-color: var(--accent);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-weight: bold;
        }
        
        .content-block {
            margin: 1.5rem 0;
        }
        
        .content-block h3 {
            display: flex;
            align-items: center;
            font-size: 1.3rem;
            margin-bottom: 0.75rem;
            color: var(--text);
        }
        
        .content-block h3 span {
            margin-right: 0.75rem;
            font-size: 1.8rem;
        }
        
        .content-block p {
            color: var(--text-secondary);
            margin-left: 2.5rem;
            font-size: 1.1rem;
        }
        
        .code-container {
            margin: 1.5rem 0;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .code-header {
            background-color: #161b22;
            color: var(--code-text);
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #30363d;
        }
        
        .code-title {
            font-weight: 600;
        }
        
        .code-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .code-action {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .code-action.close {
            background-color: #ff5f56;
        }
        
        .code-action.minimize {
            background-color: #ffbd2e;
        }
        
        .code-action.maximize {
            background-color: #27c93f;
        }
        
        .code-block {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1.5rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            overflow: auto;
            max-height: 500px;
        }
        
        .code-block code {
            display: block;
            white-space: pre;
        }
        
        .keyword {
            color: var(--code-keyword);
        }
        
        .string {
            color: var(--code-string);
        }
        
        .comment {
            color: var(--code-comment);
        }
        
        .function {
            color: var(--code-function);
        }
        
        .number {
            color: var(--code-number);
        }
        
        .tag {
            color: #7ee787;
        }
        
        .attribute {
            color: #79c0ff;
        }
        
        .business-example {
            background-color: #f0f9ff;
            border-left: 4px solid var(--primary);
            padding: 1.25rem;
            margin: 1.5rem 0;
            border-radius: 0.5rem;
        }
        
        .business-example strong {
            color: var(--primary);
        }
        
        .case-study {
            background-color: #f0fdf4;
            border-left: 4px solid var(--success);
            padding: 1.25rem;
            margin: 1.5rem 0;
            border-radius: 0.5rem;
        }
        
        .case-study strong {
            color: var(--success);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
        }
        
        .tab {
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .industry-selector {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .industry-btn {
            padding: 0.75rem 1.5rem;
            background-color: var(--light);
            border: 2px solid var(--border);
            border-radius: 2rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .industry-btn.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        footer {
            background-color: var(--dark);
            color: white;
            padding: 2rem 0;
            text-align: center;
            margin-top: 3rem;
        }
        
        .highlight {
            background-color: #fef3c7;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-weight: 600;
        }
        
        .relationship {
            display: inline-block;
            padding: 0.4rem 0.8rem;
            background-color: var(--accent);
            color: white;
            border-radius: 0.3rem;
            font-weight: 600;
            margin-left: 2.5rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Advanced Agent Building with LangChain</h1>
            <p>Comprehensive guide to building production-ready AI agents for real-world applications</p>
        </div>
    </header>
    
    <div class="container">
        <div class="section">
            <h2 class="section-title">Industry Applications</h2>
            <div class="industry-selector">
                <div class="industry-btn active" data-industry="healthcare">Healthcare</div>
                <div class="industry-btn" data-industry="retail">Retail</div>
                <div class="industry-btn" data-industry="finance">Finance</div>
                <div class="industry-btn" data-industry="logistics">Logistics</div>
            </div>
            
            <div class="card">
                <div class="component-title">
                    <div class="icon">1</div>
                    Introduction to Advanced Agents
                </div>
                
                <div class="content-block">
                    <h3><span>✅</span> Business Use Case</h3>
                    <p>
                        In healthcare, advanced AI agents can transform patient care by providing 24/7 medical assistance, analyzing patient data for early disease detection, and assisting doctors with diagnostic recommendations. For example, a hospital might deploy an agent that triages patient symptoms, retrieves relevant medical records, and suggests potential diagnoses based on the latest medical research.
                    </p>
                </div>
                
                <div class="content-block">
                    <h3><span>❌</span> Problems Solved</h3>
                    <p>
                        Advanced agents solve critical challenges in healthcare including information overload, diagnostic errors, and inefficient patient triage. They can process vast amounts of medical data quickly, provide consistent second opinions, and help healthcare professionals make more informed decisions, ultimately improving patient outcomes and reducing costs.
                    </p>
                </div>
                
                <div class="content-block">
                    <h3><span>⚠️</span> Impact if Absent</h3>
                    <p>
                        Without advanced AI agents, healthcare systems would continue to struggle with rising costs, medical errors, and inefficient processes. Patients would experience longer wait times, delayed diagnoses, and potentially suboptimal treatment plans. Healthcare providers would face increased burnout from information overload and administrative burdens.
                    </p>
                </div>
                
                <div class="content-block">
                    <h3><span>🔧</span> Predefined or Custom</h3>
                    <p>Custom</p>
                </div>
                
                <div class="content-block">
                    <h3><span>🔗</span> Relationship Keyword</h3>
                    <div class="relationship">Foundation</div>
                </div>
                
                <div class="content-block">
                    <h3><span>🧠</span> In-depth Technical Insight</h3>
                    <p>
                        Advanced agents in LangChain are built using a modular architecture that combines language models with tools, memory, and reasoning capabilities. The core components work together to create agents that can understand complex instructions, access external knowledge, and perform multi-step reasoning to solve problems.
                    </p>
                    
                    <div class="business-example">
                        <strong>Healthcare Implementation:</strong> Below is a basic structure for a healthcare diagnostic agent:
                    </div>
                    
                    <div class="code-container">
                        <div class="code-header">
                            <div class="code-title">healthcare_agent.py</div>
                            <div class="code-actions">
                                <div class="code-action close"></div>
                                <div class="code-action minimize"></div>
                                <div class="code-action maximize"></div>
                            </div>
                        </div>
                        <div class="code-block">
<code><span class="comment"># Import core LangChain components</span>
<span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentExecutor, create_openai_tools_agent
<span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> AIMessageChunk, HumanMessage
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> langchain_core.tools <span class="keyword">import</span> tool
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter
<span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> DirectoryLoader
<span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA

<span class="comment"># Initialize the language model</span>
llm = ChatOpenAI(model=<span class="string">"gpt-4-turbo"</span>, temperature=<span class="number">0.2</span>)

<span class="comment"># Define medical tools</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">retrieve_patient_records</span>(patient_id: str) -> str:
    <span class="string">"""Retrieve patient medical records by ID."""</span>
    <span class="comment"># In a real implementation, this would connect to an EHR system</span>
    records = {
        <span class="string">"P12345"</span>: {
            <span class="string">"name"</span>: <span class="string">"John Doe"</span>,
            <span class="string">"age"</span>: <span class="number">45</span>,
            <span class="string">"conditions"</span>: [<span class="string">"Hypertension"</span>, <span class="string">"Type 2 Diabetes"</span>],
            <span class="string">"medications"</span>: [<span class="string">"Lisinopril 10mg"</span>, <span class="string">"Metformin 500mg"</span>],
            <span class="string">"allergies"</span>: [<span class="string">"Penicillin"</span>]
        }
    }
    <span class="keyword">return</span> str(records.get(patient_id, <span class="string">"Patient not found"</span>))

<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">search_medical_literature</span>(query: str) -> str:
    <span class="string">"""Search medical literature for relevant information."""</span>
    <span class="comment"># This would connect to a medical database like PubMed</span>
    <span class="keyword">return</span> <span class="string">f"Recent studies on {query} show promising results with new treatment options."</span>

<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">check_drug_interactions</span>(medications: list) -> str:
    <span class="string">"""Check for potential drug interactions."""</span>
    <span class="comment"># This would connect to a drug interaction database</span>
    <span class="keyword">if</span> <span class="string">"Lisinopril"</span> <span class="keyword">in</span> medications <span class="keyword">and</span> <span class="string">"Ibuprofen"</span> <span class="keyword">in</span> medications:
        <span class="keyword">return</span> <span class="string">"Warning: Potential interaction between Lisinopril and Ibuprofen may reduce kidney function."</span>
    <span class="keyword">return</span> <span class="string">"No significant interactions detected."</span>

<span class="comment"># Set up vector store for medical knowledge</span>
<span class="keyword">def</span> <span class="function">setup_medical_knowledge_base</span>():
    <span class="comment"># Load medical documents</span>
    loader = DirectoryLoader(<span class="string">'./medical_docs/'</span>, glob=<span class="string">"**/*.txt"</span>)
    documents = loader.load()
    
    <span class="comment"># Split documents into chunks</span>
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">200</span>)
    texts = text_splitter.split_documents(documents)
    
    <span class="comment"># Create embeddings and vector store</span>
    embeddings = OpenAIEmbeddings()
    vectorstore = Chroma.from_documents(documents=texts, embedding=embeddings)
    
    <span class="keyword">return</span> vectorstore

<span class="comment"># Create the prompt template</span>
prompt = ChatPromptTemplate.from_messages([
    (<span class="string">"system"</span>, <span class="string">"""You are a medical assistant AI. Your goal is to help healthcare professionals 
    with patient care by providing accurate medical information and assistance. 
    Use the tools available to you to retrieve patient records, search medical literature, 
    and check for drug interactions. Always prioritize patient safety and provide 
    evidence-based recommendations."""</span>),
    MessagesPlaceholder(variable_name=<span class="string">"chat_history"</span>),
    (<span class="string">"human"</span>, <span class="string">"{input}"</span>),
    MessagesPlaceholder(variable_name=<span class="string">"agent_scratchpad"</span>),
])

<span class="comment"># Set up tools</span>
tools = [retrieve_patient_records, search_medical_literature, check_drug_interactions]

<span class="comment"># Create the agent</span>
agent = create_openai_tools_agent(llm, tools, prompt)

<span class="comment"># Create the agent executor</span>
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=<span class="keyword">True</span>,
    max_iterations=<span class="number">10</span>,
    early_stopping_method=<span class="string">"generate"</span>
)

<span class="comment"># Initialize medical knowledge base</span>
medical_kb = setup_medical_knowledge_base()

<span class="comment"># Create a retrieval chain for medical knowledge</span>
qa_chain = RetrievalQA.from_chain_type(
    llm=llm,
    chain_type=<span class="string">"stuff"</span>,
    retriever=medical_kb.as_retriever()
)

<span class="comment"># Example usage</span>
<span class="keyword">def</span> <span class="function">medical_consultation</span>(patient_id, query):
    <span class="comment"># First retrieve patient records</span>
    patient_data = retrieve_patient_records.run(patient_id)
    
    <span class="comment"># Then process the query with the agent</span>
    result = agent_executor.invoke({
        <span class="string">"input"</span>: f<span class="string">"Patient ID: {patient_id}. Patient data: {patient_data}. Query: {query}"</span>,
        <span class="string">"chat_history"</span>: []
    })
    
    <span class="keyword">return</span> result[<span class="string">'output'</span>]

<span class="comment"># Test the agent</span>
response = medical_consultation(
    <span class="string">"P12345"</span>, 
    <span class="string">"The patient is experiencing chest pain and shortness of breath. What could be the cause and what immediate actions should be taken?"</span>
)
print(response)</code>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2 class="section-title">Core Components</h2>
            
            <div class="tabs">
                <div class="tab active" data-tab="models">Models</div>
                <div class="tab" data-tab="data">Data Processing</div>
                <div class="tab" data-tab="retrieval">Retrieval</div>
                <div class="tab" data-tab="tools">Tools & Agents</div>
                <div class="tab" data-tab="advanced">Advanced</div>
            </div>
            
            <div class="tab-content active" id="models">
                <div class="card">
                    <div class="component-title">
                        <div class="icon">2</div>
                        Chat Models & LLMs
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In retail, chat models power virtual shopping assistants that help customers find products, provide recommendations, and answer questions about inventory. For example, a fashion retailer might use an LLM-powered assistant that understands customer style preferences, suggests outfits, and checks real-time inventory across multiple store locations.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Chat models solve the challenge of providing personalized customer service at scale. They can handle thousands of simultaneous customer inquiries, maintain consistent brand voice, and access product information instantly, reducing wait times and improving customer satisfaction.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without chat models, retailers would need to hire large customer service teams to handle inquiries, leading to higher operational costs and inconsistent service quality. Customers would experience longer wait times, especially during peak shopping seasons, resulting in lost sales opportunities.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Predefined</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Foundation</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Chat models and LLMs form the core reasoning engine of AI agents. LangChain provides a unified interface to work with various model providers (OpenAI, Anthropic, Cohere, etc.) and allows for fine-tuning behavior through parameters like temperature, max tokens, and stop sequences.
                        </p>
                        
                        <div class="business-example">
                            <strong>Retail Implementation:</strong> Setting up a retail chat model with custom behavior:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">retail_chat_model.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage, AIMessage, SystemMessage
<span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate

<span class="comment"># Initialize the chat model with custom parameters</span>
chat_model = ChatOpenAI(
    model=<span class="string">"gpt-4-turbo"</span>,
    temperature=<span class="number">0.3</span>,  <span class="comment"># Lower temperature for more consistent responses</span>
    max_tokens=<span class="number">1000</span>,  <span class="comment"># Limit response length</span>
    model_kwargs={
        <span class="string">"top_p"</span>: <span class="number">0.9</span>,
        <span class="string">"frequency_penalty"</span>: <span class="number">0.2</span>,
        <span class="string">"presence_penalty"</span>: <span class="number">0.1</span>
    }
)

<span class="comment"># Create a system prompt for the retail assistant</span>
system_prompt = <span class="string">"""You are a friendly and knowledgeable shopping assistant for a fashion retailer.
Your goal is to help customers find the perfect products based on their preferences, needs, and budget.
Always be polite, helpful, and accurate. If you don't know something, admit it and offer to find more information.
Remember to:
1. Ask clarifying questions about style preferences, size, and budget
2. Provide detailed product information including materials, care instructions, and availability
3. Suggest complementary items to complete the outfit
4. Check real-time inventory when possible
5. Offer alternatives if the requested item is out of stock"""</span>

<span class="comment"># Create a prompt template</span>
prompt_template = ChatPromptTemplate.from_messages([
    (<span class="string">"system"</span>, system_prompt),
    (<span class="string">"human"</span>, <span class="string">"{customer_query}"</span>),
])

<span class="comment"># Create a chain with output parsing</span>
retail_chain = prompt_template | chat_model | StrOutputParser()

<span class="comment"># Function to handle customer inquiries</span>
<span class="keyword">def</span> <span class="function">handle_customer_inquiry</span>(customer_query):
    <span class="comment"># Invoke the chain with the customer query</span>
    response = retail_chain.invoke({<span class="string">"customer_query"</span>: customer_query})
    
    <span class="keyword">return</span> response

<span class="comment"># Example usage</span>
customer_question = <span class="string">"I'm looking for a summer dress for a beach wedding. I prefer something in blue or green, size medium, and my budget is around $150."</span>
assistant_response = handle_customer_inquiry(customer_question)
print(assistant_response)

<span class="comment"># Output example:</span>
<span class="comment"># "I'd be happy to help you find the perfect dress for a beach wedding! We have several options that might work for you.</span>
<span class="comment">#</span>
<span class="comment"># 1. Ocean Breeze Maxi Dress - $129.99</span>
<span class="comment">#    - Material: Lightweight cotton blend</span>
<span class="comment">#    - Color: Turquoise blue</span>
<span class="comment">#    - Features: Flowing silhouette, adjustable straps, side slit</span>
<span class="comment">#    - Available in size M</span>
<span class="comment">#</span>
<span class="comment"># 2. Emerald Garden Dress - $139.99</span>
<span class="comment">#    - Material: Viscose with floral print</span>
<span class="comment">#    - Color: Emerald green</span>
<span class="comment">#    - Features: V-neck, elastic waist, ruffle hem</span>
<span class="comment">#    - Available in size M</span>
<span class="comment">#</span>
<span class="comment"># Both dresses are perfect for a beach wedding as they're made of breathable materials and have elegant yet casual styles.</span>
<span class="comment"># Would you like more details about either of these options, or would you like to see some complementary accessories?"</span></code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="component-title">
                        <div class="icon">3</div>
                        Messages & Prompt Templates
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In logistics, messages and prompt templates enable intelligent supply chain assistants that can track shipments, optimize delivery routes, and handle customer inquiries. For example, a logistics company might use templated messages to automatically notify customers about shipment status changes, delays, or delivery confirmations in a consistent brand voice.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Messages and prompt templates solve the challenge of maintaining consistent communication across thousands of customer interactions. They ensure that all communications follow company guidelines, include necessary information, and adapt to different scenarios without requiring manual intervention for each message.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without structured messages and templates, logistics companies would struggle with inconsistent customer communications, potentially leading to confusion about shipment status, delivery times, and procedures. This could result in increased customer service calls, delivery disputes, and damage to the company's reputation.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Custom</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Interface</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Messages in LangChain represent different types of communication (system, human, AI) that form the conversation history. Prompt templates allow for dynamic insertion of variables into predefined message structures, enabling consistent yet personalized interactions.
                        </p>
                        
                        <div class="business-example">
                            <strong>Logistics Implementation:</strong> Creating a shipment notification system:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">logistics_messages.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> SystemMessage, HumanMessage, AIMessage
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser
<span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnablePassthrough
<span class="keyword">from</span> datetime <span class="keyword">import</span> datetime

<span class="comment"># Initialize the language model</span>
llm = ChatOpenAI(model=<span class="string">"gpt-4-turbo"</span>, temperature=<span class="number">0.2</span>)

<span class="comment"># Define message templates for different shipment scenarios</span>
shipment_notification_template = <span class="string">"""
You are a customer service assistant for Global Logistics, a worldwide shipping company.
Your task is to notify customers about their shipment status in a professional, friendly, and helpful manner.
Always include:
1. Shipment tracking number
2. Current status and location
3. Estimated delivery date
4. Next steps if applicable
5. Contact information for further questions

Shipment details:
- Tracking Number: {tracking_number}
- Status: {status}
- Current Location: {location}
- Estimated Delivery: {estimated_delivery}
- Special Instructions: {special_instructions}
"""</span>

delay_notification_template = <span class="string">"""
You are a customer service assistant for Global Logistics.
You need to inform a customer about a shipment delay. Be apologetic but professional, and provide:
1. Reason for the delay
2. New estimated delivery date
3. Compensation or discount being offered
4. Option to speak with a representative

Shipment details:
- Tracking Number: {tracking_number}
- Original Delivery Date: {original_delivery}
- New Estimated Delivery: {new_delivery}
- Delay Reason: {delay_reason}
- Compensation: {compensation}
"""</span>

delivery_confirmation_template = <span class="string">"""
You are a customer service assistant for Global Logistics.
You need to confirm successful delivery of a shipment. Be congratulatory and include:
1. Delivery confirmation with date and time
2. Who received the package (if available)
3. Feedback request
4. Information about returns or exchanges

Shipment details:
- Tracking Number: {tracking_number}
- Delivery Date: {delivery_date}
- Delivery Time: {delivery_time}
- Recipient: {recipient}
- Feedback Link: {feedback_link}
"""</span>

<span class="comment"># Create prompt templates</span>
shipment_prompt = ChatPromptTemplate.from_template(shipment_notification_template)
delay_prompt = ChatPromptTemplate.from_template(delay_notification_template)
delivery_prompt = ChatPromptTemplate.from_template(delivery_confirmation_template)

<span class="comment"># Create chains for each scenario</span>
shipment_chain = (
    {<span class="string">"tracking_number"</span>: RunnablePassthrough(), 
     <span class="string">"status"</span>: RunnablePassthrough(), 
     <span class="string">"location"</span>: RunnablePassthrough(),
     <span class="string">"estimated_delivery"</span>: RunnablePassthrough(),
     <span class="string">"special_instructions"</span>: RunnablePassthrough()}
    | shipment_prompt
    | llm
    | StrOutputParser()
)

delay_chain = (
    {<span class="string">"tracking_number"</span>: RunnablePassthrough(), 
     <span class="string">"original_delivery"</span>: RunnablePassthrough(), 
     <span class="string">"new_delivery"</span>: RunnablePassthrough(),
     <span class="string">"delay_reason"</span>: RunnablePassthrough(),
     <span class="string">"compensation"</span>: RunnablePassthrough()}
    | delay_prompt
    | llm
    | StrOutputParser()
)

delivery_chain = (
    {<span class="string">"tracking_number"</span>: RunnablePassthrough(), 
     <span class="string">"delivery_date"</span>: RunnablePassthrough(), 
     <span class="string">"delivery_time"</span>: RunnablePassthrough(),
     <span class="string">"recipient"</span>: RunnablePassthrough(),
     <span class="string">"feedback_link"</span>: RunnablePassthrough()}
    | delivery_prompt
    | llm
    | StrOutputParser()
)

<span class="comment"># Function to generate shipment notifications</span>
<span class="keyword">def</span> <span class="function">generate_shipment_notification</span>(tracking_number, status, location, estimated_delivery, special_instructions):
    <span class="keyword">return</span> shipment_chain.invoke({
        <span class="string">"tracking_number"</span>: tracking_number,
        <span class="string">"status"</span>: status,
        <span class="string">"location"</span>: location,
        <span class="string">"estimated_delivery"</span>: estimated_delivery,
        <span class="string">"special_instructions"</span>: special_instructions
    })

<span class="keyword">def</span> <span class="function">generate_delay_notification</span>(tracking_number, original_delivery, new_delivery, delay_reason, compensation):
    <span class="keyword">return</span> delay_chain.invoke({
        <span class="string">"tracking_number"</span>: tracking_number,
        <span class="string">"original_delivery"</span>: original_delivery,
        <span class="string">"new_delivery"</span>: new_delivery,
        <span class="string">"delay_reason"</span>: delay_reason,
        <span class="string">"compensation"</span>: compensation
    })

<span class="keyword">def</span> <span class="function">generate_delivery_confirmation</span>(tracking_number, delivery_date, delivery_time, recipient, feedback_link):
    <span class="keyword">return</span> delivery_chain.invoke({
        <span class="string">"tracking_number"</span>: tracking_number,
        <span class="string">"delivery_date"</span>: delivery_date,
        <span class="string">"delivery_time"</span>: delivery_time,
        <span class="string">"recipient"</span>: recipient,
        <span class="string">"feedback_link"</span>: feedback_link
    })

<span class="comment"># Example usage</span>
notification = generate_shipment_notification(
    tracking_number=<span class="string">"GL123456789"</span>,
    status=<span class="string">"In Transit"</span>,
    location=<span class="string">"Chicago Distribution Center"</span>,
    estimated_delivery=<span class="string">"2023-06-15"</span>,
    special_instructions=<span class="string">"Signature required"</span>
)
print(notification)

<span class="comment"># Output example:</span>
<span class="comment"># "Dear Customer,</span>
<span class="comment">#</span>
<span class="comment"># We're writing to update you on your shipment with tracking number GL123456789.</span>
<span class="comment">#</span>
<span class="comment"># Current Status: In Transit</span>
<span class="comment"># Current Location: Chicago Distribution Center</span>
<span class="comment"># Estimated Delivery: June 15, 2023</span>
<span class="comment">#</span>
<span class="comment"># Your package is on its way and progressing through our network. Please note that a signature will be required upon delivery.</span>
<span class="comment">#</span>
<span class="comment"># You can track your shipment in real-time using our tracking portal or mobile app.</span>
<span class="comment">#</span>
<span class="comment"># If you have any questions or need assistance, please contact our customer service team at 1-800-LOGISTICS or support@globallogistics.com.</span>
<span class="comment">#</span>
<span class="comment"># Thank you for choosing Global Logistics!</span>
<span class="comment">#</span>
<span class="comment"># Sincerely,</span>
<span class="comment"># The Global Logistics Team"</span></code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="component-title">
                        <div class="icon">4</div>
                        Output Parsers
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In finance, output parsers enable automated financial analysis systems that can extract structured data from unstructured financial reports, news articles, and market commentary. For example, an investment firm might use output parsers to automatically extract key financial metrics from earnings reports, sentiment from market news, and structured recommendations from analyst reports.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Output parsers solve the challenge of converting unstructured LLM responses into structured data that can be used by downstream systems. They enable reliable extraction of specific information types, ensure consistent data formats, and facilitate integration with databases, APIs, and other business systems.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without output parsers, financial institutions would need to manually process and structure data from LLM responses, leading to inefficiencies, errors, and delays in decision-making. This could result in missed investment opportunities, slower response to market changes, and increased operational costs.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Both</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Control</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Output parsers in LangChain transform the raw string output from language models into structured formats like JSON, XML, or custom objects. They include predefined parsers for common formats and allow for custom parsing logic to handle specific business requirements.
                        </p>
                        
                        <div class="business-example">
                            <strong>Finance Implementation:</strong> Extracting financial data from earnings reports:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">financial_output_parser.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> JsonOutputParser, PydanticOutputParser
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> langchain_core.pydantic_v1 <span class="keyword">import</span> BaseModel, Field
<span class="keyword">from</span> typing <span class="keyword">import</span> List, Dict, Optional
<span class="keyword">from</span> enum <span class="keyword">import</span> Enum

<span class="comment"># Define data models for financial data extraction</span>
<span class="keyword">class</span> <span class="function">FinancialMetric</span>(BaseModel):
    name: str = Field(description=<span class="string">"Name of the financial metric"</span>)
    value: float = Field(description=<span class="string">"Value of the financial metric"</span>)
    unit: str = Field(description=<span class="string">"Unit of measurement (e.g., millions, billions, percentage)"</span>)
    period: str = Field(description=<span class="string">"Time period for the metric (e.g., Q1 2023, FY 2022)"</span>)

<span class="keyword">class</span> <span class="function">SentimentAnalysis</span>(BaseModel):
    sentiment: str = Field(description=<span class="string">"Overall sentiment (positive, negative, neutral)"</span>)
    confidence: float = Field(description=<span class="string">"Confidence score between 0 and 1"</span>)
    key_factors: List[str] = Field(description=<span class="string">"Key factors influencing the sentiment"</span>)

<span class="keyword">class</span> <span class="function">InvestmentRecommendation</span>(BaseModel):
    action: str = Field(description=<span class="string">"Recommended action (buy, hold, sell)"</span>)
    target_price: Optional[float] = Field(description=<span class="string">"Target price for the stock"</span>)
    time_horizon: str = Field(description=<span class="string">"Recommended investment time horizon"</span>)
    reasoning: str = Field(description=<span class="string">"Reasoning behind the recommendation"</span>)
    risk_level: str = Field(description=<span class="string">"Risk level (low, medium, high)"</span>)

<span class="keyword">class</span> <span class="function">FinancialReportAnalysis</span>(BaseModel):
    company: str = Field(description=<span class="string">"Company name"</span>)
    report_type: str = Field(description=<span class="string">"Type of report (earnings, annual, quarterly)"</span>)
    report_date: str = Field(description=<span class="string">"Date of the report"</span>)
    financial_metrics: List[FinancialMetric] = Field(description=<span class="string">"Key financial metrics from the report"</span>)
    sentiment_analysis: SentimentAnalysis = Field(description=<span class="string">"Sentiment analysis of the report"</span>)
    investment_recommendation: InvestmentRecommendation = Field(description=<span class="string">"Investment recommendation based on the report"</span>)

<span class="comment"># Initialize the language model</span>
llm = ChatOpenAI(model=<span class="string">"gpt-4-turbo"</span>, temperature=<span class="number">0.1</span>)

<span class="comment"># Create a parser for the financial report analysis</span>
parser = PydanticOutputParser(pydantic_object=FinancialReportAnalysis)

<span class="comment"># Create a prompt template with format instructions</span>
prompt = PromptTemplate(
    template=<span class="string">"""
    Analyze the following financial report extract and extract structured information.
    
    Report extract:
    {report_text}
    
    {format_instructions}
    """</span>,
    input_variables=[<span class="string">"report_text"</span>],
    partial_variables={<span class="string">"format_instructions"</span>: parser.get_format_instructions()}
)

<span class="comment"># Create the chain</span>
chain = prompt | llm | parser

<span class="comment"># Function to analyze financial reports</span>
<span class="keyword">def</span> <span class="function">analyze_financial_report</span>(report_text):
    <span class="keyword">return</span> chain.invoke({<span class="string">"report_text"</span>: report_text})

<span class="comment"># Example usage</span>
earnings_report = <span class="string">"""
TechCorp Inc. reported Q2 2023 earnings today. Revenue increased by 15% year-over-year to $5.2 billion, 
beating analyst expectations of $4.9 billion. Net income was $1.3 billion, or $2.45 per share, compared to 
$1.1 billion, or $2.05 per share, in the same quarter last year. The company's cloud division showed 
particularly strong growth, with revenue increasing by 28% to $2.1 billion. Management raised full-year 
guidance, now expecting revenue between $20.5 billion and $21 billion, up from previous guidance of 
$19.5 billion to $20 billion. The stock is up 8% in after-hours trading following the announcement.
"""</span>

analysis_result = analyze_financial_report(earnings_report)
print(analysis_result)

<span class="comment"># Output example (structured data):</span>
<span class="comment"># company='TechCorp Inc.'</span>
<span class="comment"># report_type='earnings'</span>
<span class="comment"># report_date='Q2 2023'</span>
<span class="comment"># financial_metrics=[</span>
<span class="comment">#     FinancialMetric(name='Revenue', value=5.2, unit='billions', period='Q2 2023'),</span>
<span class="comment">#     FinancialMetric(name='Net Income', value=1.3, unit='billions', period='Q2 2023'),</span>
<span class="comment">#     FinancialMetric(name='EPS', value=2.45, unit='dollars', period='Q2 2023'),</span>
<span class="comment">#     FinancialMetric(name='Cloud Revenue', value=2.1, unit='billions', period='Q2 2023')</span>
<span class="comment"># ]</span>
<span class="comment"># sentiment_analysis=SentimentAnalysis(</span>
<span class="comment">#     sentiment='positive', </span>
<span class="comment">#     confidence=0.9, </span>
<span class="comment">#     key_factors=['Revenue beat expectations', 'Raised full-year guidance', 'Stock price increase']</span>
<span class="comment"># )</span>
<span class="comment"># investment_recommendation=InvestmentRecommendation(</span>
<span class="comment">#     action='buy', </span>
<span class="comment">#     target_price=185.0, </span>
<span class="comment">#     time_horizon='6-12 months', </span>
<span class="comment">#     reasoning='Strong earnings beat and raised guidance indicate positive momentum. Cloud division growth is particularly promising.', </span>
<span class="comment">#     risk_level='medium'</span>
<span class="comment"># )</span>

<span class="comment"># Using the JSON output parser for simpler cases</span>
json_parser = JsonOutputParser()

<span class="comment"># Create a prompt for extracting key financial metrics</span>
metrics_prompt = PromptTemplate(
    template=<span class="string">"""
    Extract key financial metrics from the following text as a JSON object.
    
    Text:
    {text}
    
    {format_instructions}
    """</span>,
    input_variables=[<span class="string">"text"</span>],
    partial_variables={<span class="string">"format_instructions"</span>: json_parser.get_format_instructions()}
)

<span class="comment"># Create the chain</span>
metrics_chain = metrics_prompt | llm | json_parser

<span class="comment"># Function to extract financial metrics</span>
<span class="keyword">def</span> <span class="function">extract_financial_metrics</span>(text):
    <span class="keyword">return</span> metrics_chain.invoke({<span class="string">"text"</span>: text})

<span class="comment"># Example usage</span>
news_text = <span class="string">"""
Global Bank announced its Q3 results today. The bank reported a net profit of $3.2 billion, 
up 12% from the previous year. Return on equity improved to 15.2% from 14.1% last year. 
The bank's loan book grew by 8% to $850 billion, while deposits increased by 6% to $1.1 trillion. 
CEO Jane Smith stated that the bank is well-positioned to navigate the current economic environment.
"""</span>

metrics = extract_financial_metrics(news_text)
print(metrics)

<span class="comment"># Output example (JSON):</span>
<span class="comment"># {</span>
<span class="comment">#   "financial_metrics": [</span>
<span class="comment">#     {</span>
<span class="comment">#       "name": "Net Profit",</span>
<span class="comment">#       "value": 3.2,</span>
<span class="comment">#       "unit": "billion dollars",</span>
<span class="comment">#       "change": "+12%"</span>
<span class="comment">#     },</span>
<span class="comment">#     {</span>
<span class="comment">#       "name": "Return on Equity",</span>
<span class="comment">#       "value": 15.2,</span>
<span class="comment">#       "unit": "percentage",</span>
<span class="comment">#       "change": "+1.1%"</span>
<span class="comment">#     },</span>
<span class="comment">#     {</span>
<span class="comment">#       "name": "Loan Book",</span>
<span class="comment">#       "value": 850,</span>
<span class="comment">#       "unit": "billion dollars",</span>
<span class="comment">#       "change": "+8%"</span>
<span class="comment">#     },</span>
<span class="comment">#     {</span>
<span class="comment">#       "name": "Deposits",</span>
<span class="comment">#       "value": 1.1,</span>
<span class="comment">#       "unit": "trillion dollars",</span>
<span class="comment">#       "change": "+6%"</span>
<span class="comment">#     }</span>
<span class="comment">#   ]</span>
<span class="comment"># }</span></code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="data">
                <div class="card">
                    <div class="component-title">
                        <div class="icon">5</div>
                        Document Loaders
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In healthcare, document loaders enable medical AI systems to ingest and process diverse medical records, research papers, and clinical guidelines. For example, a hospital might use document loaders to ingest patient records from electronic health record (EHR) systems, medical literature from PubMed, and internal hospital protocols to create a comprehensive knowledge base for clinical decision support.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Document loaders solve the challenge of integrating data from multiple sources and formats into a unified system. They handle the complexities of different file types (PDFs, Word documents, text files, etc.), data structures, and access methods, enabling organizations to leverage all their available data for AI applications.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without document loaders, healthcare organizations would need to develop custom integration solutions for each data source, leading to significant development overhead, maintenance challenges, and potential data inconsistencies. This would delay the deployment of AI systems that could improve patient care and operational efficiency.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Both</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Foundation</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Document loaders in LangChain provide a unified interface to load documents from various sources. They include loaders for local files, cloud storage, databases, APIs, and more. Each loader returns documents in a standardized format that can be processed by other LangChain components.
                        </p>
                        
                        <div class="business-example">
                            <strong>Healthcare Implementation:</strong> Loading medical documents from multiple sources:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">healthcare_document_loaders.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> (
    DirectoryLoader, 
    PyPDFLoader, 
    TextLoader,
    CSVLoader,
    UnstructuredWordDocumentLoader,
    WebBaseLoader,
    PubMedLoader
)
<span class="keyword">from</span> langchain_community.document_loaders.mongodb <span class="keyword">import</span> MongodbLoader
<span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> RecursiveCharacterTextSplitter
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma
<span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document
<span class="keyword">import</span> os

<span class="comment"># Function to load patient records from EHR system (simulated with local files)</span>
<span class="keyword">def</span> <span class="function">load_patient_records</span>(ehr_directory):
    <span class="string">"""Load patient records from EHR system directory."""</span>
    <span class="comment"># Use DirectoryLoader to load all documents in the directory</span>
    loader = DirectoryLoader(
        ehr_directory,
        glob=<span class="string">"**/*.pdf"</span>,
        loader_cls=PyPDFLoader,
        recursive=<span class="keyword">True</span>,
        show_progress=<span class="keyword">True</span>
    )
    documents = loader.load()
    
    <span class="comment"># Add metadata to identify the source</span>
    <span class="keyword">for</span> doc <span class="keyword">in</span> documents:
        doc.metadata[<span class="string">"source"</span>] = <span class="string">"EHR"</span>
        doc.metadata[<span class="string">"type"</span>] = <span class="string">"patient_record"</span>
    
    <span class="keyword">return</span> documents

<span class="comment"># Function to load medical literature from PubMed</span>
<span class="keyword">def</span> <span class="function">load_medical_literature</span>(query, max_docs=10):
    <span class="string">"""Load medical literature from PubMed based on a query."""</span>
    loader = PubMedLoader(query=query, load_max_docs=max_docs)
    documents = loader.load()
    
    <span class="comment"># Add metadata to identify the source</span>
    <span class="keyword">for</span> doc <span class="keyword">in</span> documents:
        doc.metadata[<span class="string">"source"</span>] = <span class="string">"PubMed"</span>
        doc.metadata[<span class="string">"type"</span>] = <span class="string">"research_paper"</span>
    
    <span class="keyword">return</span> documents

<span class="comment"># Function to load clinical guidelines from web sources</span>
<span class="keyword">def</span> <span class="function">load_clinical_guidelines</span>(urls):
    <span class="string">"""Load clinical guidelines from web URLs."""</span>
    loader = WebBaseLoader(urls)
    documents = loader.load()
    
    <span class="comment"># Add metadata to identify the source</span>
    <span class="keyword">for</span> doc <span class="keyword">in</span> documents:
        doc.metadata[<span class="string">"source"</span>] = <span class="string">"Web"</span>
        doc.metadata[<span class="string">"type"</span>] = <span class="string">"clinical_guideline"</span>
    
    <span class="keyword">return</span> documents

<span class="comment"># Function to load hospital protocols from Word documents</span>
<span class="keyword">def</span> <span class="function">load_hospital_protocols</span>(protocols_directory):
    <span class="string">"""Load hospital protocols from Word documents."""</span>
    loader = DirectoryLoader(
        protocols_directory,
        glob=<span class="string">"**/*.docx"</span>,
        loader_cls=UnstructuredWordDocumentLoader,
        recursive=<span class="keyword">True</span>,
        show_progress=<span class="keyword">True</span>
    )
    documents = loader.load()
    
    <span class="comment"># Add metadata to identify the source</span>
    <span class="keyword">for</span> doc <span class="keyword">in</span> documents:
        doc.metadata[<span class="string">"source"</span>] = <span class="string">"Hospital"</span>
        doc.metadata[<span class="string">"type"</span>] = <span class="string">"protocol"</span>
    
    <span class="keyword">return</span> documents

<span class="comment"># Function to load drug information from CSV files</span>
<span class="keyword">def</span> <span class="function">load_drug_database</span>(csv_file_path):
    <span class="string">"""Load drug information from CSV file."""</span>
    loader = CSVLoader(
        file_path=csv_file_path,
        source_column=<span class="string">"drug_name"</span>,
        metadata_columns=[<span class="string">"category"</span>, <span class="string">"manufacturer"</span>]
    )
    documents = loader.load()
    
    <span class="comment"># Add metadata to identify the source</span>
    <span class="keyword">for</span> doc <span class="keyword">in</span> documents:
        doc.metadata[<span class="string">"source"</span>] = <span class="string">"DrugDB"</span>
        doc.metadata[<span class="string">"type"</span>] = <span class="string">"drug_info"</span>
    
    <span class="keyword">return</span> documents

<span class="comment"># Function to load data from MongoDB (for EHR integration)</span>
<span class="keyword">def</span> <span class="function">load_from_mongodb</span>(connection_string, db_name, collection_name):
    <span class="string">"""Load documents from MongoDB collection."""</span>
    loader = MongodbLoader(
        connection_string=connection_string,
        db_name=db_name,
        collection_name=collection_name,
    )
    documents = loader.load()
    
    <span class="comment"># Add metadata to identify the source</span>
    <span class="keyword">for</span> doc <span class="keyword">in</span> documents:
        doc.metadata[<span class="string">"source"</span>] = <span class="string">"MongoDB"</span>
        doc.metadata[<span class="string">"type"</span>] = <span class="string">"ehr_data"</span>
    
    <span class="keyword">return</span> documents

<span class="comment"># Function to process and split documents</span>
<span class="keyword">def</span> <span class="function">process_documents</span>(documents):
    <span class="string">"""Process documents by splitting them into chunks."""</span>
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=<span class="number">1000</span>,
        chunk_overlap=<span class="number">200</span>,
        length_function=<span class="keyword">len</span>,
    )
    chunks = text_splitter.split_documents(documents)
    <span class="keyword">return</span> chunks

<span class="comment"># Function to create vector store from documents</span>
<span class="keyword">def</span> <span class="function">create_vector_store</span>(documents, collection_name):
    <span class="string">"""Create a vector store from documents for retrieval."""</span>
    embeddings = OpenAIEmbeddings()
    vectorstore = Chroma.from_documents(
        documents=documents,
        embedding=embeddings,
        collection_name=collection_name,
        persist_directory=<span class="string">"./chroma_db"</span>
    )
    <span class="keyword">return</span> vectorstore

<span class="comment"># Main function to load all healthcare data</span>
<span class="keyword">def</span> <span class="function">load_all_healthcare_data</span>():
    <span class="string">"""Load and process all healthcare data from various sources."""</span>
    all_documents = []
    
    <span class="comment"># Load patient records</span>
    <span class="keyword">try</span>:
        patient_records = load_patient_records(<span class="string">"./data/patient_records/"</span>)
        all_documents.extend(patient_records)
        print(<span class="string">f"Loaded {len(patient_records)} patient records"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(<span class="string">f"Error loading patient records: {e}"</span>)
    
    <span class="comment"># Load medical literature</span>
    <span class="keyword">try</span>:
        literature = load_medical_literature(<span class="string">"diabetes treatment guidelines 2023"</span>, max_docs=20)
        all_documents.extend(literature)
        print(<span class="string">f"Loaded {len(literature)} research papers"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(<span class="string">f"Error loading medical literature: {e}"</span>)
    
    <span class="comment"># Load clinical guidelines</span>
    <span class="keyword">try</span>:
        guidelines = load_clinical_guidelines([
            <span class="string">"https://www.who.int/publications/i/item/WHO-UCN-HIP-2021.1"</span>,
            <span class="string">"https://www.nice.org.uk/guidance/ng28"</span>
        ])
        all_documents.extend(guidelines)
        print(<span class="string">f"Loaded {len(guidelines)} clinical guidelines"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(<span class="string">f"Error loading clinical guidelines: {e}"</span>)
    
    <span class="comment"># Load hospital protocols</span>
    <span class="keyword">try</span>:
        protocols = load_hospital_protocols(<span class="string">"./data/hospital_protocols/"</span>)
        all_documents.extend(protocols)
        print(<span class="string">f"Loaded {len(protocols)} hospital protocols"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(<span class="string">f"Error loading hospital protocols: {e}"</span>)
    
    <span class="comment"># Load drug database</span>
    <span class="keyword">try</span>:
        drugs = load_drug_database(<span class="string">"./data/drugs/drug_database.csv"</span>)
        all_documents.extend(drugs)
        print(<span class="string">f"Loaded {len(drugs)} drug information entries"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(<span class="string">f"Error loading drug database: {e}"</span>)
    
    <span class="comment"># Load from MongoDB (if connection available)</span>
    <span class="keyword">try</span>:
        mongodb_docs = load_from_mongodb(
            connection_string=<span class="string">"mongodb://localhost:27017/"</span>,
            db_name=<span class="string">"ehr"</span>,
            collection_name=<span class="string">"patients"</span>
        )
        all_documents.extend(mongodb_docs)
        print(<span class="string">f"Loaded {len(mongodb_docs)} documents from MongoDB"</span>)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(<span class="string">f"Error loading from MongoDB: {e}"</span>)
    
    <span class="comment"># Process documents</span>
    processed_docs = process_documents(all_documents)
    print(<span class="string">f"Processed into {len(processed_docs)} chunks"</span>)
    
    <span class="comment"># Create vector store</span>
    vectorstore = create_vector_store(processed_docs, <span class="string">"healthcare_knowledge"</span>)
    print(<span class="string">"Created vector store for healthcare knowledge"</span>)
    
    <span class="keyword">return</span> vectorstore

<span class="comment"># Execute the data loading process</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    healthcare_vectorstore = load_all_healthcare_data()
    print(<span class="string">"Healthcare data loading complete!"</span>)</code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="component-title">
                        <div class="icon">6</div>
                        Text Splitters
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In retail, text splitters enable product recommendation systems to process detailed product descriptions, customer reviews, and category information. For example, an e-commerce platform might use text splitters to break down lengthy product specifications into manageable chunks that can be effectively embedded and matched with customer preferences.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Text splitters solve the challenge of processing large documents that exceed the context window of language models. They intelligently divide text into smaller, coherent chunks that preserve semantic meaning, enabling effective embedding, retrieval, and processing of large documents.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without text splitters, retail systems would struggle to process detailed product information, leading to less accurate product recommendations, poor search results, and missed opportunities for cross-selling. This would result in lower conversion rates and reduced customer satisfaction.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Both</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Foundation</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Text splitters in LangChain provide various strategies for dividing text into chunks, including character-based, token-based, and semantic splitting. They allow customization of chunk size, overlap, and splitting criteria to optimize for different use cases and document types.
                        </p>
                        
                        <div class="business-example">
                            <strong>Retail Implementation:</strong> Splitting product descriptions for better recommendations:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">retail_text_splitters.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> (
    RecursiveCharacterTextSplitter,
    CharacterTextSplitter,
    TokenTextSplitter,
    SemanticChunker
)
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma
<span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document
<span class="keyword">from</span> langchain_experimental.text_splitter <span class="keyword">import</span> SemanticChunker
<span class="keyword">import</span> tiktoken

<span class="comment"># Example product description</span>
product_description = <span class="string">"""
Premium Wireless Noise-Canceling Headphones

Experience unparalleled sound quality with our Premium Wireless Noise-Canceling Headphones. 
These headphones feature advanced active noise cancellation technology that blocks out up to 95% 
of ambient noise, allowing you to immerse yourself in your music, podcasts, or calls.

Key Features:
- Active Noise Cancellation: Our proprietary ANC technology uses multiple microphones to detect 
  and eliminate unwanted sounds, creating a peaceful listening environment.
- High-Resolution Audio: Supports Hi-Res Audio certification, delivering crystal-clear sound 
  with deep bass and crisp highs.
- 30-Hour Battery Life: Enjoy up to 30 hours of playback with ANC on, or up to 40 hours with ANC off. 
  A quick 15-minute charge provides 3 hours of playback.
- Comfortable Design: Memory foam ear cushions and an adjustable headband ensure all-day comfort. 
  The headphones fold compactly for easy storage in the included carrying case.
- Multipoint Connection: Connect to two devices simultaneously and seamlessly switch between them. 
  Perfect for switching between your laptop and smartphone.
- Touch Controls: Intuitive touch controls on the earcups allow you to play/pause music, 
  skip tracks, adjust volume, and take calls with simple gestures.
- Voice Assistant Support: Access your preferred voice assistant with the touch of a button. 
  Compatible with Siri, Google Assistant, and Alexa.
- Premium Materials: Constructed with durable materials including aluminum alloy earcups 
  and a stainless steel headband for long-lasting quality.

Technical Specifications:
- Driver Size: 40mm dynamic drivers
- Frequency Response: 4Hz - 40kHz
- Impedance: 32 Ohms
- Sensitivity: 105dB
- Bluetooth Version: 5.2 with support for aptX HD and LDAC codecs
- Weight: 250g
- Charging Time: 2 hours (full charge)
- Included Accessories: Hard carrying case, 3.5mm audio cable, USB-C charging cable, 
  airplane adapter, and quick start guide.

Warranty:
- 2-year manufacturer warranty with extended warranty options available.

Customer Reviews:
- "The sound quality is exceptional, and the noise cancellation is the best I've experienced." 
  - Verified Buyer
- "Battery life is incredible. I can go days without charging." - Verified Buyer
- "Comfortable for long listening sessions. Great for flights." - Verified Buyer
"""</span>

<span class="comment"># Create a document from the product description</span>
product_doc = Document(
    page_content=product_description,
    metadata={
        <span class="string">"product_id"</span>: <span class="string">"WH-1000XM5"</span>,
        <span class="string">"category"</span>: <span class="string">"Electronics > Audio > Headphones"</span>,
        <span class="string">"brand"</span>: <span class="string">"AudioTech"</span>,
        <span class="string">"price"</span>: <span class="string">"$349.99"</span>
    }
)

<span class="comment"># Function to demonstrate different text splitting strategies</span>
<span class="keyword">def</span> <span class="function">demonstrate_text_splitters</span>():
    <span class="string">"""Demonstrate different text splitting strategies for retail product data."""</span>
    
    print(<span class="string">"=== Text Splitting Strategies for Retail Products ===\n"</span>)
    
    <span class="comment"># 1. Recursive Character Text Splitter</span>
    print(<span class="string">"1. Recursive Character Text Splitter:"</span>)
    recursive_splitter = RecursiveCharacterTextSplitter(
        chunk_size=<span class="number">500</span>,
        chunk_overlap=<span class="number">50</span>,
        length_function=<span class="keyword">len</span>,
        separators=[<span class="string">"\n\n"</span>, <span class="string">"\n"</span>, <span class="string">". "</span>, <span class="string">", "</span>, <span class="string">" "</span>]
    )
    recursive_chunks = recursive_splitter.split_documents([product_doc])
    print(<span class="string">f"Number of chunks: {len(recursive_chunks)}"</span>)
    print(<span class="string">"First chunk:"</span>)
    print(recursive_chunks[<span class="number">0</span>].page_content)
    print(<span class="string">"-" * 50 + <span class="string">"\n</span>"</span>)
    
    <span class="comment"># 2. Token Text Splitter</span>
    print(<span class="string">"2. Token Text Splitter:"</span>)
    token_splitter = TokenTextSplitter(
        chunk_size=<span class="number">100</span>,  <span class="comment"># 100 tokens per chunk</span>
        chunk_overlap=<span class="number">10</span>
    )
    token_chunks = token_splitter.split_documents([product_doc])
    print(<span class="string">f"Number of chunks: {len(token_chunks)}"</span>)
    print(<span class="string">"First chunk:"</span>)
    print(token_chunks[<span class="number">0</span>].page_content)
    print(<span class="string">"-" * 50 + <span class="string">"\n</span>"</span>)
    
    <span class="comment"># 3. Semantic Chunker (if available)</span>
    print(<span class="string">"3. Semantic Chunker:"</span>)
    <span class="keyword">try</span>:
        embeddings = OpenAIEmbeddings()
        semantic_splitter = SemanticChunker(
            embeddings=embeddings,
            breakpoint_threshold_type=<span class="string">"percentile"</span>,
            breakpoint_threshold_amount=<span class="number">90</span>
        )
        semantic_chunks = semantic_splitter.split_documents([product_doc])
        print(<span class="string">f"Number of chunks: {len(semantic_chunks)}"</span>)
        print(<span class="string">"First chunk:"</span>)
        print(semantic_chunks[<span class="number">0</span>].page_content)
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        print(f<span class="string">"Semantic chunker not available: {e}"</span>)
    print(<span class="string">"-" * 50 + <span class="string">"\n</span>"</span>)
    
    <span class="comment"># 4. Custom Splitter for Product Specifications</span>
    print(<span class="string">"4. Custom Product Specification Splitter:"</span>)
    
    <span class="keyword">class</span> <span class="function">ProductSpecSplitter</span>:
        <span class="keyword">def</span> <span class="function">__init__</span>(self):
            <span class="keyword">pass</span>
        
        <span class="keyword">def</span> <span class="function">split_text</span>(self, text):
            <span class="string">"""Split product description into logical sections."""</span>
            chunks = []
            
            <span class="comment"># Split by major sections</span>
            sections = text.split(<span class="string">"\n\n"</span>)
            
            <span class="keyword">for</span> section <span class="keyword">in</span> sections:
                <span class="keyword">if</span> section.strip():
                    <span class="comment"># Further split large sections</span>
                    <span class="keyword">if</span> <span class="keyword">len</span>(section) > <span class="number">800</span>:
                        <span class="comment"># Split by lines for large sections</span>
                        lines = section.split(<span class="string">"\n"</span>)
                        current_chunk = <span class="string">""</span>
                        
                        <span class="keyword">for</span> line <span class="keyword">in</span> lines:
                            <span class="keyword">if</span> <span class="keyword">len</span>(current_chunk) + <span class="keyword">len</span>(line) + <span class="number">1</span> < <span class="number">800</span>:
                                current_chunk += line + <span class="string">"\n"</span>
                            <span class="keyword">else</span>:
                                <span class="keyword">if</span> current_chunk.strip():
                                    chunks.append(current_chunk.strip())
                                current_chunk = line + <span class="string">"\n"</span>
                        
                        <span class="keyword">if</span> current_chunk.strip():
                            chunks.append(current_chunk.strip())
                    <span class="keyword">else</span>:
                        chunks.append(section.strip())
            
            <span class="keyword">return</span> chunks
        
        <span class="keyword">def</span> <span class="function">split_documents</span>(self, documents):
            <span class="string">"""Split documents using the custom splitter."""</span>
            all_chunks = []
            
            <span class="keyword">for</span> doc <span class="keyword">in</span> documents:
                chunks = self.split_text(doc.page_content)
                
                <span class="keyword">for</span> i, chunk <span class="keyword">in</span> enumerate(chunks):
                    chunk_doc = Document(
                        page_content=chunk,
                        metadata={
                            **doc.metadata,
                            <span class="string">"chunk_id"</span>: i
                        }
                    )
                    all_chunks.append(chunk_doc)
            
            <span class="keyword">return</span> all_chunks
    
    custom_splitter = ProductSpecSplitter()
    custom_chunks = custom_splitter.split_documents([product_doc])
    print(<span class="string">f"Number of chunks: {len(custom_chunks)}"</span>)
    print(<span class="string">"First chunk:"</span>)
    print(custom_chunks[<span class="number">0</span>].page_content)
    print(<span class="string">"-" * 50 + <span class="string">"\n</span>"</span>)
    
    <span class="keyword">return</span> recursive_chunks, token_chunks, custom_chunks

<span class="comment"># Function to create embeddings and vector store</span>
<span class="keyword">def</span> <span class="function">create_product_vector_store</span>(chunks):
    <span class="string">"""Create a vector store from product chunks for recommendations."""</span>
    embeddings = OpenAIEmbeddings()
    vectorstore = Chroma.from_documents(
        documents=chunks,
        embedding=embeddings,
        collection_name=<span class="string">"product_recommendations"</span>,
        persist_directory=<span class="string">"./chroma_db"</span>
    )
    <span class="keyword">return</span> vectorstore

<span class="comment"># Function to demonstrate product recommendations</span>
<span class="keyword">def</span> <span class="function">demonstrate_recommendations</span>(vectorstore):
    <span class="string">"""Demonstrate product recommendations using the vector store."""</span>
    <span class="comment"># Create a retriever</span>
    retriever = vectorstore.as_retriever(search_kwargs={<span class="string">"k"</span>: <span class="number">3</span>})
    
    <span class="comment"># Example customer query</span>
    query = <span class="string">"I need headphones with long battery life for travel"</span>
    
    <span class="comment"># Retrieve relevant chunks</span>
    relevant_chunks = retriever.invoke(query)
    
    print(<span class="string">"=== Product Recommendations ==="</span>)
    print(<span class="string">f"Query: {query}\n"</span>)
    print(<span class="string">"Relevant product features:"</span>)
    
    <span class="keyword">for</span> i, chunk <span class="keyword">in</span> enumerate(relevant_chunks, <span class="number">1</span>):
        print(<span class="string">f"\nRecommendation {i}:"</span>)
        print(chunk.page_content[:<span class="number">200</span>] + <span class="string">"..."</span>)
        print(<span class="string">"Metadata:"</span>, chunk.metadata)

<span class="comment"># Main execution</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Demonstrate text splitting strategies</span>
    recursive_chunks, token_chunks, custom_chunks = demonstrate_text_splitters()
    
    <span class="comment"># Create vector store with custom chunks (best for product data)</span>
    product_vectorstore = create_product_vector_store(custom_chunks)
    
    <span class="comment"># Demonstrate recommendations</span>
    demonstrate_recommendations(product_vectorstore)</code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="component-title">
                        <div class="icon">7</div>
                        Embedding Models
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In logistics, embedding models power intelligent supply chain systems that can match shipments with optimal carriers, predict delivery times, and identify potential disruptions. For example, a logistics company might use embeddings to represent shipment characteristics, carrier capabilities, and historical performance data to make real-time routing decisions.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Embedding models solve the challenge of representing complex, unstructured data in a way that enables semantic similarity comparisons and machine learning applications. They convert text, images, and other data into numerical vectors that capture meaning and relationships, enabling sophisticated analysis and retrieval.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without embedding models, logistics companies would struggle to optimize supply chain operations, leading to inefficient routing, higher costs, and delayed deliveries. They would miss opportunities for predictive analytics and real-time decision-making that could significantly improve operational efficiency.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Both</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Foundation</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Embedding models in LangChain provide a unified interface to various embedding providers (OpenAI, Hugging Face, Cohere, etc.) and allow for fine-tuning on domain-specific data. They transform text into high-dimensional vectors that capture semantic meaning, enabling similarity search, clustering, and other vector-based operations.
                        </p>
                        
                        <div class="business-example">
                            <strong>Logistics Implementation:</strong> Creating embeddings for logistics optimization:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">logistics_embeddings.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain_huggingface <span class="keyword">import</span> HuggingFaceEmbeddings
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma, FAISS
<span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document
<span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">import</span> pandas <span class="keyword">as</span> pd

<span class="comment"># Example logistics data</span>
shipments = [
    {
        <span class="string">"shipment_id"</span>: <span class="string">"S12345"</span>,
        <span class="string">"origin"</span>: <span class="string">"New York, NY"</span>,
        <span class="string">"destination"</span>: <span class="string">"Los Angeles, CA"</span>,
        <span class="string">"weight"</span>: <span class="string">"500 lbs"</span>,
        <span class="string">"dimensions"</span>: <span class="string">"48x40x36 inches"</span>,
        <span class="string">"contents"</span>: <span class="string">"Electronics"</span>,
        <span class="string">"priority"</span>: <span class="string">"High"</span>,
        <span class="string">"special_requirements"</span>: <span class="string">"Temperature controlled, fragile"</span>
    },
    {
        <span class="string">"shipment_id"</span>: <span class="string">"S67890"</span>,
        <span class="string">"origin"</span>: <span class="string">"Chicago, IL"</span>,
        <span class="string">"destination"</span>: <span class="string">"Miami, FL"</span>,
        <span class="string">"weight"</span>: <span class="string">"1200 lbs"</span>,
        <span class="string">"dimensions"</span>: <span class="string">"72x48x48 inches"</span>,
        <span class="string">"contents"</span>: <span class="string">"Automotive parts"</span>,
        <span class="string">"priority"</span>: <span class="string">"Medium"</span>,
        <span class="string">"special_requirements"</span>: <span class="string">"None"</span>
    },
    {
        <span class="string">"shipment_id"</span>: <span class="string">"S24680"</span>,
        <span class="string">"origin"</span>: <span class="string">"Seattle, WA"</span>,
        <span class="string">"destination"</span>: <span class="string">"Boston, MA"</span>,
        <span class="string">"weight"</span>: <span class="string">"800 lbs"</span>,
        <span class="string">"dimensions"</span>: <span class="string">">60x40x40 inches"</span>,
        <span class="string">"contents"</span>: <span class="string">"Pharmaceuticals"</span>,
        <span class="string">"priority"</span>: <span class="string">"High"</span>,
        <span class="string">"special_requirements"</span>: <span class="string">"Refrigerated, security"</span>
    }
]

carriers = [
    {
        <span class="string">"carrier_id"</span>: <span class="string">"C001"</span>,
        <span class="string">"name"</span>: <span class="string">"Global Express"</span>,
        <span class="string">"service_type"</span>: <span class="string">"Expedited"</span>,
        <span class="string">"coverage"</span>: <span class="string">"Nationwide"</span>,
        <span class="string">"specialties"</span>: <span class="string">"Temperature controlled, high-value goods"</span>,
        <span class="string">"reliability_score"</span>: <span class="string">"98%"</span>
    },
    {
        <span class="string">"carrier_id"</span>: <span class="string">"C002"</span>,
        <span class="string">"name"</span>: <span class="string">"Freight Masters"</span>,
        <span class="string">"service_type"</span>: <span class="string">"Standard"</span>,
        <span class="string">"coverage"</span>: <span class="string">"Continental US"</span>,
        <span class="string">"specialties"</span>: <span class="string">"Heavy freight, oversized loads"</span>,
        <span class="string">"reliability_score"</span>: <span class="string">"95%"</span>
    },
    {
        <span class="string">"carrier_id"</span>: <span class="string">"C003"</span>,
        <span class="string">"name"</span>: <span class="string">"Secure Transit"</span>,
        <span class="string">"service_type"</span>: <span class="string">"Premium"</span>,
        <span class="string">"coverage"</span>: <span class="string">"Nationwide and international"</span>,
        <span class="string">"specialties"</span>: <span class="string">"High-security, pharmaceuticals"</span>,
        <span class="string">"reliability_score"</span>: <span class="string">"99%"</span>
    }
]

<span class="comment"># Function to create documents from logistics data</span>
<span class="keyword">def</span> <span class="function">create_logistics_documents</span>():
    <span class="string">"""Create documents from shipment and carrier data."""</span>
    shipment_docs = []
    carrier_docs = []
    
    <span class="comment"># Create shipment documents</span>
    <span class="keyword">for</span> shipment <span class="keyword">in</span> shipments:
        content = f<span class="string">"Shipment {shipment['shipment_id']} from {shipment['origin']} to {shipment['destination']}. "</span> \
                   f<span class="string">"Weight: {shipment['weight']}, Dimensions: {shipment['dimensions']}. "</span> \
                   f<span class="string">"Contents: {shipment['contents']}, Priority: {shipment['priority']}. "</span> \
                   f<span class="string">"Special requirements: {shipment['special_requirements']}."</span>
        
        doc = Document(
            page_content=content,
            metadata={
                <span class="string">"type"</span>: <span class="string">"shipment"</span>,
                <span class="string">"shipment_id"</span>: shipment[<span class="string">"shipment_id"</span>],
                <span class="string">"origin"</span>: shipment[<span class="string">"origin"</span>],
                <span class="string">"destination"</span>: shipment[<span class="string">"destination"</span>],
                <span class="string">"weight"</span>: shipment[<span class="string">"weight"</span>],
                <span class="string">"contents"</span>: shipment[<span class="string">"contents"</span>],
                <span class="string">"priority"</span>: shipment[<span class="string">"priority"</span>],
                <span class="string">"special_requirements"</span>: shipment[<span class="string">"special_requirements"</span>]
            }
        )
        shipment_docs.append(doc)
    
    <span class="comment"># Create carrier documents</span>
    <span class="keyword">for</span> carrier <span class="keyword">in</span> carriers:
        content = f<span class="string">"Carrier {carrier['carrier_id']}: {carrier['name']}. "</span> \
                   f<span class="string">"Service type: {carrier['service_type']}, Coverage: {carrier['coverage']}. "</span> \
                   f<span class="string">"Specialties: {carrier['specialties']}. "</span> \
                   f<span class="string">"Reliability score: {carrier['reliability_score']}."</span>
        
        doc = Document(
            page_content=content,
            metadata={
                <span class="string">"type"</span>: <span class="string">"carrier"</span>,
                <span class="string">"carrier_id"</span>: carrier[<span class="string">"carrier_id"</span>],
                <span class="string">"name"</span>: carrier[<span class="string">"name"</span>],
                <span class="string">"service_type"</span>: carrier[<span class="string">"service_type"</span>],
                <span class="string">"coverage"</span>: carrier[<span class="string">"coverage"</span>],
                <span class="string">"specialties"</span>: carrier[<span class="string">"specialties"</span>],
                <span class="string">"reliability_score"</span>: carrier[<span class="string">"reliability_score"</span>]
            }
        )
        carrier_docs.append(doc)
    
    <span class="keyword">return</span> shipment_docs, carrier_docs

<span class="comment"># Function to demonstrate different embedding models</span>
<span class="keyword">def</span> <span class="function">demonstrate_embedding_models</span>(documents):
    <span class="string">"""Demonstrate different embedding models for logistics data."""</span>
    print(<span class="string">"=== Embedding Models for Logistics ===\n"</span>)
    
    <span class="comment"># 1. OpenAI Embeddings</span>
    print(<span class="string">"1. OpenAI Embeddings:"</span>)
    openai_embeddings = OpenAIEmbeddings(model=<span class="string">"text-embedding-3-small"</span>)
    
    <span class="comment"># Create embeddings for the first document</span>
    doc_text = documents[<span class="number">0</span>].page_content
    openai_vector = openai_embeddings.embed_query(doc_text)
    print(<span class="string">f"Vector dimension: {len(openai_vector)}"</span>)
    print(<span class="string">f"First 5 values: {openai_vector[:5]}"</span>)
    print(<span class="string">"-" * 50 + <span class="string">"\n</span>"</span>)
    
    <span class="comment"># 2. Hugging Face Embeddings</span>
    print(<span class="string">"2. Hugging Face Embeddings:"</span>)
    hf_embeddings = HuggingFaceEmbeddings(
        model_name=<span class="string">"sentence-transformers/all-MiniLM-L6-v2"</span>
    )
    
    <span class="comment"># Create embeddings for the first document</span>
    hf_vector = hf_embeddings.embed_query(doc_text)
    print(<span class="string">f"Vector dimension: {len(hf_vector)}"</span>)
    print(<span class="string">f"First 5 values: {hf_vector[:5]}"</span>)
    print(<span class="string">"-" * 50 + <span class="string">"\n</span>"</span>)
    
    <span class="comment"># 3. Custom Embeddings (simulated)</span>
    print(<span class="string">"3. Custom Logistics Embeddings:"</span>)
    
    <span class="keyword">class</span> <span class="function">LogisticsEmbeddings</span>:
        <span class="keyword">def</span> <span class="function">__init__</span>(self):
            <span class="comment"># In a real implementation, this would be a trained model</span>
            <span class="comment"># Here we simulate with a simple weighted approach</span>
            <span class="keyword">pass</span>
        
        <span class="keyword">def</span> <span class="function">embed_documents</span>(self, texts):
            <span class="string">"""Embed a list of documents."""</span>
            vectors = []
            <span class="keyword">for</span> text <span class="keyword">in</span> texts:
                vectors.append(self.embed_query(text))
            <span class="keyword">return</span> vectors
        
        <span class="keyword">def</span> <span class="function">embed_query</span>(self, text):
            <span class="string">"""Embed a single query text."""</span>
            <span class="comment"># Simulate embedding with keyword-based approach</span>
            keywords = {
                <span class="string">"high"</span>: <span class="number">0.9</span>,
                <span class="string">"temperature"</span>: <span class="number">0.8</span>,
                <span class="string">"controlled"</span>: <span class="number">0.7</span>,
                <span class="string">"refrigerated"</span>: <span class="number">0.85</span>,
                <span class="string">"security"</span>: <span class="number">0.75</span>,
                <span class="string">"fragile"</span>: <span class="number">0.65</span>,
                <span class="string">"heavy"</span>: <span class="number">0.6</span>,
                <span class="string">"oversized"</span>: <span class="number">0.55</span>,
                <span class="string">"expedited"</span>: <span class="number">0.7</span>,
                <span class="string">"standard"</span>: <span class="number">0.4</span>
            }
            
            text_lower = text.lower()
            vector = np.zeros(<span class="number">10</span>)  <span class="comment"># 10-dimensional vector</span>
            
            <span class="keyword">for</span> i, (keyword, weight) <span class="keyword">in</span> enumerate(keywords.items()):
                <span class="keyword">if</span> keyword <span class="keyword">in</span> text_lower:
                    vector[i] = weight
            
            <span class="keyword">return</span> vector.tolist()
    
    custom_embeddings = LogisticsEmbeddings()
    custom_vector = custom_embeddings.embed_query(doc_text)
    print(<span class="string">f"Vector dimension: {len(custom_vector)}"</span>)
    print(<span class="string">f"Vector values: {custom_vector}"</span>)
    print(<span class="string">"-" * 50 + <span class="string">"\n</span>"</span>)
    
    <span class="keyword">return</span> openai_embeddings, hf_embeddings, custom_embeddings

<span class="comment"># Function to create vector stores</span>
<span class="keyword">def</span> <span class="function">create_vector_stores</span>(shipment_docs, carrier_docs, embeddings):
    <span class="string">"""Create vector stores for shipments and carriers."""</span>
    
    <span class="comment"># Create shipment vector store</span>
    shipment_vectorstore = Chroma.from_documents(
        documents=shipment_docs,
        embedding=embeddings,
        collection_name=<span class="string">"shipments"</span>,
        persist_directory=<span class="string">"./chroma_db"</span>
    )
    
    <span class="comment"># Create carrier vector store</span>
    carrier_vectorstore = FAISS.from_documents(
        documents=carrier_docs,
        embedding=embeddings
    )
    
    <span class="keyword">return</span> shipment_vectorstore, carrier_vectorstore

<span class="comment"># Function to find optimal carrier for a shipment</span>
<span class="keyword">def</span> <span class="function">find_optimal_carrier</span>(shipment_query, shipment_vectorstore, carrier_vectorstore):
    <span class="string">"""Find the optimal carrier for a given shipment using embeddings."""</span>
    
    <span class="comment"># Step 1: Find similar shipments to understand requirements</span>
    similar_shipments = shipment_vectorstore.similarity_search(shipment_query, k=<span class="number">2</span>)
    
    print(<span class="string">"=== Finding Optimal Carrier ==="</span>)
    print(<span class="string">f"Shipment Query: {shipment_query}\n"</span>)
    print(<span class="string">"Similar Shipments:"</span>)
    <span class="keyword">for</span> i, doc <span class="keyword">in</span> enumerate(similar_shipments, <span class="number">1</span>):
        print(<span class="string">f"{i}. {doc.page_content}"</span>)
    
    <span class="comment"># Step 2: Find carriers that match the shipment requirements</span>
    <span class="comment"># Use the similar shipments to create a combined query</span>
    combined_query = shipment_query
    <span class="keyword">for</span> doc <span class="keyword">in</span> similar_shipments:
        combined_query += <span class="string">" "</span> + doc.page_content
    
    matching_carriers = carrier_vectorstore.similarity_search(combined_query, k=<span class="number">3</span>)
    
    print(<span class="string">"\nMatching Carriers:"</span>)
    <span class="keyword">for</span> i, doc <span class="keyword">in</span> enumerate(matching_carriers, <span class="number">1</span>):
        print(<span class="string">f"{i}. {doc.page_content}"</span>)
    
    <span class="comment"># Step 3: Calculate similarity scores for ranking</span>
    <span class="comment"># In a real implementation, this would use more sophisticated matching</span>
    carrier_scores = []
    
    <span class="keyword">for</span> carrier_doc <span class="keyword">in</span> matching_carriers:
        <span class="comment"># Simple scoring based on keyword matches</span>
        score = <span class="number">0</span>
        
        <span class="keyword">if</span> <span class="string">"high"</span> <span class="keyword">in</span> shipment_query.lower() <span class="keyword">and</span> <span class="string">"expedited"</span> <span class="keyword">in</span> carrier_doc.page_content.lower():
            score += <span class="number">3</span>
        
        <span class="keyword">if</span> <span class="string">"temperature"</span> <span class="keyword">in</span> shipment_query.lower() <span class="keyword">and</span> <span class="string">"temperature"</span> <span class="keyword">in</span> carrier_doc.page_content.lower():
            score += <span class="number">3</span>
        
        <span class="keyword">if</span> <span class="string">"security"</span> <span class="keyword">in</span> shipment_query.lower() <span class="keyword">and</span> <span class="string">"security"</span> <span class="keyword">in</span> carrier_doc.page_content.lower():
            score += <span class="number">3</span>
        
        <span class="keyword">if</span> <span class="string">"fragile"</span> <span class="keyword">in</span> shipment_query.lower() <span class="keyword">and</span> <span class="string">"high-value"</span> <span class="keyword">in</span> carrier_doc.page_content.lower():
            score += <span class="number">2</span>
        
        <span class="comment"># Add reliability score</span>
        reliability = <span class="keyword">int</span>(carrier_doc.metadata[<span class="string">"reliability_score"</span>].replace(<span class="string">"%"</span>, <span class="string">""</span>))
        score += reliability / <span class="number">20</span>  <span class="comment"># Scale reliability to 0-5 range</span>
        
        carrier_scores.append({
            <span class="string">"carrier"</span>: carrier_doc,
            <span class="string">"score"</span>: score
        })
    
    <span class="comment"># Sort carriers by score</span>
    carrier_scores.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">"score"</span>], reverse=<span class="keyword">True</span>)
    
    print(<span class="string">"\nRanked Carriers:"</span>)
    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(carrier_scores, <span class="number">1</span>):
        carrier = item[<span class="string">"carrier"</span>]
        score = item[<span class="string">"score"</span>]
        print(<span class="string">f"{i}. {carrier.metadata['name']} - Score: {score:.2f}"</span>)
    
    <span class="keyword">return</span> carrier_scores[<span class="number">0</span>][<span class="string">"carrier"</span>]  <span class="comment"># Return the best carrier</span>

<span class="comment"># Main execution</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Create documents</span>
    shipment_docs, carrier_docs = create_logistics_documents()
    
    <span class="comment"># Demonstrate embedding models</span>
    openai_embeddings, hf_embeddings, custom_embeddings = demonstrate_embedding_models(shipment_docs)
    
    <span class="comment"># Create vector stores using OpenAI embeddings</span>
    shipment_vectorstore, carrier_vectorstore = create_vector_stores(
        shipment_docs, carrier_docs, openai_embeddings
    )
    
    <span class="comment"># Example shipment query</span>
    shipment_query = <span class="string">"High priority shipment of pharmaceuticals requiring temperature control and security from Seattle to Boston"</span>
    
    <span class="comment"># Find optimal carrier</span>
    best_carrier = find_optimal_carrier(shipment_query, shipment_vectorstore, carrier_vectorstore)
    
    print(<span class="string">f"\nRecommended Carrier: {best_carrier.metadata['name']}"</span>)
    print(<span class="string">f"Reason: Best match for high priority, temperature control, and security requirements"</span>)</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="retrieval">
                <div class="card">
                    <div class="component-title">
                        <div class="icon">8</div>
                        Vector Stores & Retrievers
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In healthcare, vector stores and retrievers power clinical decision support systems that can quickly find relevant medical literature, patient records, and treatment guidelines. For example, a hospital might use a vector store to index millions of medical documents, allowing doctors to retrieve relevant information about rare diseases or treatment options in seconds.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Vector stores and retrievers solve the challenge of efficiently searching and retrieving relevant information from large datasets. They enable semantic search capabilities that understand the meaning behind queries, rather than just matching keywords, leading to more accurate and contextually relevant results.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without vector stores and retrievers, healthcare systems would rely on traditional keyword-based search, which often fails to capture the semantic meaning of medical queries. This would lead to missed information, slower decision-making, and potentially suboptimal patient care, especially in complex or rare medical cases.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Both</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Execution</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Vector stores in LangChain provide efficient storage and retrieval of document embeddings. They support various backends (Chroma, FAISS, Pinecone, etc.) and offer different search strategies (similarity search, MMR, etc.). Retrievers wrap vector stores to provide a consistent interface for fetching relevant documents.
                        </p>
                        
                        <div class="business-example">
                            <strong>Healthcare Implementation:</strong> Building a medical knowledge retrieval system:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">healthcare_retrieval.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma, FAISS, Pinecone
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document
<span class="keyword">from</span> langchain_core.retrievers <span class="keyword">import</span> BaseRetriever
<span class="keyword">from</span> langchain_core.callbacks <span class="keyword">import</span> CallbackManagerForRetrieverRun
<span class="keyword">from</span> typing <span class="keyword">import</span> List
<span class="keyword">import</span> os

<span class="comment"># Example medical documents</span>
medical_documents = [
    Document(
        page_content=<span class="string">"Diabetes mellitus is a group of metabolic disorders characterized by high blood sugar levels over a prolonged period. Symptoms include frequent urination, increased thirst, and increased hunger. Acute complications include diabetic ketoacidosis, hyperosmolar hyperglycemic state, or death. Serious long-term complications include cardiovascular disease, stroke, chronic kidney disease, foot ulcers, and damage to the eyes."</span>,
        metadata={<span class="string">"source"</span>: <span class="string">"Medical Encyclopedia"</span>, <span class="string">"type"</span>: <span class="string">"disease"</span>, <span class="string">"id"</span>: <span class="string">"D001"</span>}
    ),
    Document(
        page_content=<span class="string">"Treatment for type 2 diabetes involves lifestyle changes (diet and exercise), blood sugar monitoring, and oral medications. If these measures are not sufficient, insulin therapy may be required. Metformin is generally recommended as a first-line treatment. Other medications include sulfonylureas, thiazolidinediones, DPP-4 inhibitors, SGLT-2 inhibitors, and GLP-1 receptor agonists."</span>,
        metadata={<span class="string">"source"</span>: <span class="string">"Treatment Guidelines"</span>, <span class="string">"type"</span>: <span class="string">"treatment"</span>, <span class="string">"id"</span>: <span class="string">"T001"</span>}
    ),
    Document(
        page_content=<span class="string">"Hypertension, also known as high blood pressure, is a long-term medical condition in which the blood pressure in the arteries is persistently elevated. High blood pressure usually does not cause symptoms. Long-term high blood pressure is a major risk factor for stroke, heart attack, heart failure, and peripheral arterial disease."</span>,
        metadata={<span class="string">"source"</span>: <span class="string">"Medical Encyclopedia"</span>, <span class="string">"type"</span>: <span class="string">"disease"</span>, <span class="string">"id"</span>: <span class="string">"D002"</span>}
    ),
    Document(
        page_content=<span class="string">"Treatment of hypertension includes lifestyle changes and medications. Lifestyle changes include weight loss, decreased salt intake, physical exercise, and a healthy diet. If lifestyle changes are not sufficient, blood pressure medications are used. Common medications include thiazide diuretics, ACE inhibitors, angiotensin receptor blockers, calcium channel blockers, and beta-blockers."</span>,
        metadata={<span class="string">"source"</span>: <span class="string">"Treatment Guidelines"</span>, <span class="string">"type"</span>: <span class="string">"treatment"</span>, <span class="string">"id"</span>: <span class="string">"T002"</span>}
    ),
    Document(
        page_content=<span class="string">"Asthma is a common long-term inflammatory disease of the airways of the lungs. It is characterized by variable and recurring symptoms, reversible airflow obstruction, and easily triggered bronchospasms. Symptoms include episodes of wheezing, coughing, chest tightness, and shortness of breath."</span>,
        metadata={<span class="string">"source"</span>: <span class="string">"Medical Encyclopedia"</span>, <span class="string">"type"</span>: <span class="string">"disease"</span>, <span class="string">"id"</span>: <span class="string">"D003"</span>}
    ),
    Document(
        page_content=<span class="string">"Treatment of asthma focuses on avoiding triggers, controlling symptoms, and preventing asthma attacks. Medications include inhaled corticosteroids, long-acting beta agonists (LABAs), leukotriene modifiers, and theophylline. Quick-relief medications include short-acting beta agonists (SABAs) like albuterol. Severe cases may require oral corticosteroids."</span>,
        metadata={<span class="string">"source"</span>: <span class="string">"Treatment Guidelines"</span>, <span class="string">"type"</span>: <span class="string">"treatment"</span>, <span class="string">"id"</span>: <span class="string">"T003"</span>}
    )
]

<span class="comment"># Function to create different vector stores</span>
<span class="keyword">def</span> <span class="function">create_vector_stores</span>(documents):
    <span class="string">"""Create different types of vector stores for medical knowledge."""</span>
    embeddings = OpenAIEmbeddings()
    
    <span class="comment"># 1. Chroma vector store (persistent)</span>
    chroma_db = Chroma.from_documents(
        documents=documents,
        embedding=embeddings,
        collection_name=<span class="string">"medical_knowledge"</span>,
        persist_directory=<span class="string">"./chroma_db"</span>
    )
    
    <span class="comment"># 2. FAISS vector store (in-memory)</span>
    faiss_db = FAISS.from_documents(
        documents=documents,
        embedding=embeddings
    )
    
    <span class="comment"># 3. Pinecone vector store (cloud-based) - if API key available</span>
    pinecone_db = <span class="keyword">None</span>
    <span class="keyword">if</span> os.getenv(<span class="string">"PINECONE_API_KEY"</span>):
        <span class="keyword">from</span> pinecone <span class="keyword">import</span> Pinecone <span class="keyword">as</span> PineconeClient
        <span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Pinecone <span class="keyword">as</span> LangchainPinecone
        
        pc = PineconeClient(api_key=os.getenv(<span class="string">"PINECONE_API_KEY"</span>))
        index_name = <span class="string">"medical-knowledge"</span>
        
        <span class="comment"># Create index if it doesn't exist</span>
        <span class="keyword">if</span> index_name <span class="keyword">not</span> <span class="keyword">in</span> pc.list_indexes():
            pc.create_index(
                name=index_name,
                dimension=<span class="number">1536</span>,  <span class="comment"># OpenAI embedding dimension</span>
                metric=<span class="string">"cosine"</span>
            )
        
        pinecone_db = LangchainPinecone.from_documents(
            documents=documents,
            embedding=embeddings,
            index_name=index_name
        )
    
    <span class="keyword">return</span> chroma_db, faiss_db, pinecone_db

<span class="comment"># Custom retriever for medical queries</span>
<span class="keyword">class</span> <span class="function">MedicalRetriever</span>(BaseRetriever):
    <span class="string">"""Custom retriever for medical knowledge with enhanced filtering."""</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(self, vectorstore, metadata_filters=None):
        <span class="keyword">self</span>.vectorstore = vectorstore
        <span class="keyword">self</span>.metadata_filters = metadata_filters <span class="keyword">or</span> {}
    
    <span class="keyword">def</span> _get_relevant_documents(
        <span class="keyword">self</span>, query: str, *, run_manager: CallbackManagerForRetrieverRun
    ) -> List[Document]:
        <span class="string">"""Retrieve documents based on query and metadata filters."""</span>
        
        <span class="comment"># Apply metadata filters if provided</span>
        <span class="keyword">if</span> <span class="keyword">self</span>.metadata_filters:
            <span class="comment"># Create filter expression</span>
            filter_expr = {}
            <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="keyword">self</span>.metadata_filters.items():
                filter_expr[key] = value
            
            <span class="comment"># Search with filters</span>
            docs = <span class="keyword">self</span>.vectorstore.similarity_search(
                query, 
                k=<span class="number">5</span>, 
                filter=filter_expr
            )
        <span class="keyword">else</span>:
            <span class="comment"># Standard similarity search</span>
            docs = <span class="keyword">self</span>.vectorstore.similarity_search(query, k=<span class="number">5</span>)
        
        <span class="keyword">return</span> docs

<span class="comment"># Function to demonstrate different retrieval strategies</span>
<span class="keyword">def</span> <span class="function">demonstrate_retrieval_strategies</span>(vectorstore):
    <span class="string">"""Demonstrate different retrieval strategies for medical knowledge."""</span>
    print(<span class="string">"=== Retrieval Strategies for Medical Knowledge ===\n"</span>)
    
    <span class="comment"># 1. Similarity Search</span>
    print(<span class="string">"1. Similarity Search:"</span>)
    query = <span class="string">"What are the symptoms and treatment for diabetes?"</span>
    results = vectorstore.similarity_search(query, k=<span class="number">3</span>)
    
    print(<span class="string">f"Query: {query}\n"</span>)
    print(<span class="string">"Results:"</span>)
    <span class="keyword">for</span> i, doc <span class="keyword">in</span> enumerate(results, <span class="number">1</span>):
        print(<span class="string">f"{i}. {doc.page_content[:100]}..."</span>)
        print(<span class="string">f"   Metadata: {doc.metadata}\n"</span>)
    
    <span class="comment"># 2. Similarity Search with Score</span>
    print(<span class="string">"2. Similarity Search with Score:"</span>)
    results_with_scores = vectorstore.similarity_search_with_score(query, k=<span class="number">3</span>)
    
    print(<span class="string">f"Query: {query}\n"</span>)
    print(<span class="string">"Results with Scores:"</span>)
    <span class="keyword">for</span> i, (doc, score) <span class="keyword">in</span> enumerate(results_with_scores, <span class="number">1</span>):
        print(<span class="string">f"{i}. Score: {score:.4f}"</span>)
        print(<span class="string">f"   Content: {doc.page_content[:100]}...\n"</span>)
    
    <span class="comment"># 3. Maximal Marginal Relevance (MMR) Search</span>
    print(<span class="string">"3. Maximal Marginal Relevance (MMR) Search:"</span>)
    mmr_results = vectorstore.max_marginal_relevance_search(
        query, 
        k=<span class="number">3</span>, 
        fetch_k=<span class="number">10</span>,
        lambda_mult=<span class="number">0.5</span>
    )
    
    print(<span class="string">f"Query: {query}\n"</span>)
    print(<span class="string">"MMR Results:"</span>)
    <span class="keyword">for</span> i, doc <span class="keyword">in</span> enumerate(mmr_results, <span class="number">1</span>):
        print(<span class="string">f"{i}. {doc.page_content[:100]}..."</span>)
        print(<span class="string">f"   Metadata: {doc.metadata}\n"</span>)
    
    <span class="comment"># 4. Custom Medical Retriever with Metadata Filtering</span>
    print(<span class="string">"4. Custom Medical Retriever with Metadata Filtering:"</span>)
    
    <span class="comment"># Create retriever for treatment information only</span>
    treatment_retriever = MedicalRetriever(
        vectorstore=vectorstore,
        metadata_filters={<span class="string">"type"</span>: <span class="string">"treatment"</span>}
    )
    
    treatment_query = <span class="string">"How is hypertension treated?"</span>
    treatment_results = treatment_retriever.get_relevant_documents(treatment_query)
    
    print(<span class="string">f"Query: {treatment_query} (filtered for treatment information only)\n"</span>)
    print(<span class="string">"Filtered Results:"</span>)
    <span class="keyword">for</span> i, doc <span class="keyword">in</span> enumerate(treatment_results, <span class="number">1</span>):
        print(<span class="string">f"{i}. {doc.page_content[:100]}..."</span>)
        print(<span class="string">f"   Metadata: {doc.metadata}\n"</span>)

<span class="comment"># Function to demonstrate clinical decision support</span>
<span class="keyword">def</span> <span class="function">clinical_decision_support</span>(vectorstore):
    <span class="string">"""Demonstrate clinical decision support using retrieval."""</span>
    print(<span class="string">"=== Clinical Decision Support Demo ===\n"</span>)
    
    <span class="comment"># Simulate a clinical scenario</span>
    patient_case = <span class="string">"""
    Patient: 45-year-old male
    Symptoms: Frequent urination, increased thirst, fatigue
    Medical History: Obesity (BMI 32), family history of diabetes
    Lab Results: Fasting blood glucose 140 mg/dL, HbA1c 7.2%
    
    Questions:
    1. What condition might this patient have based on these symptoms and lab results?
    2. What are the recommended treatment options for this condition?
    3. What lifestyle changes would you recommend?
    """</span>
    
    print(<span class="string">"Patient Case:"</span>)
    print(patient_case)
    
    <span class="comment"># Create queries based on the case</span>
    diagnosis_query = <span class="string">"What condition is characterized by frequent urination, increased thirst, fatigue, and elevated blood glucose?"</span>
    treatment_query = <span class="string">"What are the first-line treatments for type 2 diabetes in an obese patient?"</span>
    lifestyle_query = <span class="string">"What lifestyle changes are recommended for managing type 2 diabetes?"</span>
    
    <span class="comment"># Retrieve relevant information</span>
    diagnosis_docs = vectorstore.similarity_search(diagnosis_query, k=<span class="number">2</span>)
    treatment_docs = vectorstore.similarity_search(treatment_query, k=<span class="number">2</span>)
    lifestyle_docs = vectorstore.similarity_search(lifestyle_query, k=<span class="number">2</span>)
    
    <span class="comment"># Display results</span>
    print(<span class="string">"\n=== Retrieved Medical Knowledge ==="</span>)
    
    print(<span class="string">"\n1. Potential Diagnosis:"</span>)
    <span class="keyword">for</span> doc <span class="keyword">in</span> diagnosis_docs:
        print(<span class="string">f"- {doc.page_content}"</span>)
    
    print(<span class="string">"\n2. Treatment Options:"</span>)
    <span class="keyword">for</span> doc <span class="keyword">in</span> treatment_docs:
        print(<span class="string">f"- {doc.page_content}"</span>)
    
    print(<span class="string">"\n3. Lifestyle Recommendations:"</span>)
    <span class="keyword">for</span> doc <span class="keyword">in</span> lifestyle_docs:
        print(<span class="string">f"- {doc.page_content}"</span>)
    
    <span class="comment"># Simulate clinical decision</span>
    print(<span class="string">"\n=== Clinical Decision ==="</span>)
    print(<span class="string">"Based on the retrieved medical knowledge:"</span>)
    print(<span class="string">"1. Diagnosis: The patient's symptoms and lab results are consistent with type 2 diabetes mellitus."</span>)
    print(<span class="string">"2. Treatment: First-line treatment should include metformin along with lifestyle modifications."</span>)
    print(<span class="string">"3. Lifestyle: Recommend weight loss through diet and exercise, reduced sugar intake, and regular blood glucose monitoring."</span>)

<span class="comment"># Main execution</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Create vector stores</span>
    chroma_db, faiss_db, pinecone_db = create_vector_stores(medical_documents)
    
    <span class="comment"># Demonstrate retrieval strategies using Chroma</span>
    demonstrate_retrieval_strategies(chroma_db)
    
    <span class="comment"># Demonstrate clinical decision support</span>
    clinical_decision_support(chroma_db)</code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="component-title">
                        <div class="icon">9</div>
                        Indexing
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In retail, indexing enables product search engines to efficiently organize and retrieve product information from large catalogs. For example, an e-commerce platform with millions of products might use indexing to create a searchable database that allows customers to quickly find products based on attributes like category, price range, brand, and features.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Indexing solves the challenge of organizing large amounts of data for efficient retrieval. It creates optimized data structures that enable fast search operations, even with complex queries and large datasets. Without indexing, searching through millions of products would be impractically slow.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without proper indexing, retail platforms would experience slow search performance, leading to frustrated customers, abandoned carts, and lost sales. The inability to efficiently filter and sort products would result in poor user experiences and decreased conversion rates.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Both</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Foundation</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Indexing in LangChain involves creating optimized data structures from documents for efficient retrieval. The indexing API handles the entire pipeline from document loading to storage in a vector database, including deduplication, content extraction, and embedding generation.
                        </p>
                        
                        <div class="business-example">
                            <strong>Retail Implementation:</strong> Building a product catalog index:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">retail_indexing.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain.indexes <span class="keyword">import</span> Index
<span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> RecursiveCharacterTextSplitter
<span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> CSVLoader, DirectoryLoader
<span class="keyword">from</span> langchain_core.indexing <span class="keyword">import</span> RecordManager
<span class="keyword">from</span> langchain_community.indexes <span class="keyword">import</span> get_docstore
<span class="keyword">from</span> langchain.storage <span class="keyword">import</span> InMemoryStore
<span class="keyword">import</span> pandas <span class="keyword">as</span> pd
<span class="keyword">import</span> json
<span class="keyword">import</span> os

<span class="comment"># Example product data</span>
product_data = [
    {
        <span class="string">"product_id"</span>: <span class="string">"P1001"</span>,
        <span class="string">"name"</span>: <span class="string">"Wireless Bluetooth Headphones"</span>,
        <span class="string">"category"</span>: <span class="string">"Electronics > Audio > Headphones"</span>,
        <span class="string">"brand"</span>: <span class="string">"AudioTech"</span>,
        <span class="string">"price"</span>: <span class="number">79.99</span>,
        <span class="string">"description"</span>: <span class="string">"Premium wireless headphones with noise cancellation and 30-hour battery life. Features include Bluetooth 5.0, quick charge, and comfortable over-ear design."</span>,
        <span class="string">"features"</span>: [<span class="string">"Wireless"</span>, <span class="string">"Noise Cancelling"</span>, <span class="string">"30-hour Battery"</span>, <span class="string">"Quick Charge"</span>],
        <span class="string">"specifications"</span>: {
            <span class="string">"driver_size"</span>: <span class="string">"40mm"</span>,
            <span class="string">"frequency_response"</span>: <span class="string">"20Hz - 20kHz"</span>,
            <span class="string">"battery_life"</span>: <span class="string">"30 hours"</span>,
            <span class="string">"charging_time"</span>: <span class="string">"2 hours"</span>,
            <span class="string">"weight"</span>: <span class="string">"250g"</span>
        },
        <span class="string">"availability"</span>: <span class="keyword">True</span>,
        <span class="string">"rating"</span>: <span class="number">4.5</span>,
        <span class="string">"reviews_count"</span>: <span class="number">1240</span>
    },
    {
        <span class="string">"product_id"</span>: <span class="string">"P1002"</span>,
        <span class="string">"name"</span>: <span class="string">"Smart Fitness Watch"</span>,
        <span class="string">"category"</span>: <span class="string">"Electronics > Wearables > Smartwatches"</span>,
        <span class="string">"brand"</span>: <span class="string">"FitTech"</span>,
        <span class="string">"price"</span>: <span class="number">199.99</span>,
        <span class="string">"description"</span>: <span class="string">"Advanced fitness tracker with heart rate monitoring, GPS, and 7-day battery life. Tracks steps, calories, sleep patterns, and includes 50+ workout modes."</span>,
        <span class="string">"features"</span>: [<span class="string">"Heart Rate Monitor"</span>, <span class="string">"GPS"</span>, <span class="string">"7-day Battery"</span>, <span class="string">"Water Resistant"</span>],
        <span class="string">"specifications"</span>: {
            <span class="string">"display"</span>: <span class="string">"1.3 inch AMOLED"</span>,
            <span class="string">"battery_life"</span>: <span class="string">"7 days"</span>,
            <span class="string">"water_resistance"</span>: <span class="string">"5ATM"</span>,
            <span class="string">"sensors"</span>: <span class="string">"Heart rate, Accelerometer, Gyroscope, GPS"</span>,
            <span class="string">"compatibility"</span>: <span class="string">"iOS 12+, Android 6+"</span>
        },
        <span class="string">"availability"</span>: <span class="keyword">True</span>,
        <span class="string">"rating"</span>: <span class="number">4.7</span>,
        <span class="string">"reviews_count"</span>: <span class="number">890</span>
    },
    {
        <span class="string">"product_id"</span>: <span class="string">"P1003"</span>,
        <span class="string">"name"</span>: <span class="string">"4K Ultra HD Smart TV"</span>,
        <span class="string">"category"</span>: <span class="string">"Electronics > TVs > Smart TVs"</span>,
        <span class="string">"brand"</span>: <span class="string">"ViewTech"</span>,
        <span class="string">"price"</span>: <span class="number">599.99</span>,
        <span class="string">"description"</span>: <span class="string">"55-inch 4K UHD Smart TV with HDR support and built-in streaming apps. Features include voice control, Dolby Vision, and a sleek bezel-less design."</span>,
        <span class="string">"features"</span>: [<span class="string">"4K UHD"</span>, <span class="string">"HDR"</span>, <span class="string">"Smart TV"</span>, <span class="string">"Voice Control"</span>],
        <span class="string">"specifications"</span>: {
            <span class="string">"screen_size"</span>: <span class="string">"55 inches"</span>,
            <span class="string">"resolution"</span>: <span class="string">"3840 x 2160"</span>,
            <span class="string">"display_type"</span>: <span class="string">"LED"</span>,
            <span class="string">"refresh_rate"</span>: <span class="string">"60Hz"</span>,
            <span class="string">"smart_platform"</span>: <span class="string">"ViewTech OS"</span>
        },
        <span class="string">"availability"</span>: <span class="keyword">True</span>,
        <span class="string">"rating"</span>: <span class="number">4.3</span>,
        <span class="string">"reviews_count"</span>: <span class="number">560</span>
    }
]

<span class="comment"># Function to create product documents</span>
<span class="keyword">def</span> <span class="function">create_product_documents</span>(products):
    <span class="string">"""Create documents from product data."""</span>
    documents = []
    
    <span class="keyword">for</span> product <span class="keyword">in</span> products:
        <span class="comment"># Create a comprehensive product description</span>
        content = f<span class="string">"Product: {product['name']}\n"</span> \
                   f<span class="string">"Brand: {product['brand']}\n"</span> \
                   f<span class="string">"Category: {product['category']}\n"</span> \
                   f<span class="string">"Price: ${product['price']}\n"</span> \
                   f<span class="string">"Description: {product['description']}\n"</span> \
                   f<span class="string">"Features: {', '.join(product['features'])}\n"</span> \
                   f<span class="string">"Specifications: {json.dumps(product['specifications'])}\n"</span> \
                   f<span class="string">"Rating: {product['rating']}/5 ({product['reviews_count']} reviews)"</span>
        
        doc = Document(
            page_content=content,
            metadata={
                <span class="string">"product_id"</span>: product[<span class="string">"product_id"</span>],
                <span class="string">"name"</span>: product[<span class="string">"name"</span>],
                <span class="string">"brand"</span>: product[<span class="string">"brand"</span>],
                <span class="string">"category"</span>: product[<span class="string">"category"</span>],
                <span class="string">"price"</span>: product[<span class="string">"price"</span>],
                <span class="string">"features"</span>: product[<span class="string">"features"</span>],
                <span class="string">"rating"</span>: product[<span class="string">"rating"</span>],
                <span class="string">"availability"</span>: product[<span class="string">"availability"</span>]
            }
        )
        documents.append(doc)
    
    <span class="keyword">return</span> documents

<span class="comment"># Function to demonstrate indexing with record manager</span>
<span class="keyword">def</span> <span class="function">demonstrate_indexing_with_record_manager</span>(documents):
    <span class="string">"""Demonstrate indexing with record manager for efficient updates."""</span>
    print(<span class="string">"=== Indexing with Record Manager ===\n"</span>)
    
    <span class="comment"># Initialize embeddings</span>
    embeddings = OpenAIEmbeddings()
    
    <span class="comment"># Initialize vector store</span>
    vectorstore = Chroma(
        collection_name=<span class="string">"product_catalog"</span>,
        embedding_function=embeddings,
        persist_directory=<span class="string">"./chroma_db"</span>
    )
    
    <span class="comment"># Initialize record manager</span>
    namespace = <span class="string">"product_catalog/chroma"</span>
    record_manager = RecordManager(
        namespace=namespace,
        store=get_docstore(InMemoryStore())
    )
    
    <span class="comment"># Create index</span>
    index = Index(
        vectorstore=vectorstore,
        record_manager=record_manager,
        embedding=embeddings
    )
    
    <span class="comment"># Index documents</span>
    result = index.from_documents(
        documents,
        cleanup=<span class="string">"incremental"</span>,
        source_id_key=<span class="string">"product_id"</span>
    )
    
    print(<span class="string">"Indexing Results:"</span>)
    print(<span class="string">f"Number of documents added: {len(result['added'])}"</span>)
    print(<span class="string">f"Number of documents updated: {len(result['updated'])}"</span>)
    print(<span class="string">f"Number of documents deleted: {len(result['deleted'])}"</span>)
    print(<span class="string">f"Number of documents skipped: {len(result['skipped'])}"</span>)
    
    <span class="keyword">return</span> index

<span class="comment"># Function to demonstrate updating the index</span>
<span class="keyword">def</span> <span class="function">demonstrate_index_updates</span>(index, original_products):
    <span class="string">"""Demonstrate updating the index with new and modified products."""</span>
    print(<span class="string">"\n=== Demonstrating Index Updates ===\n"</span>)
    
    <span class="comment"># Create updated product data</span>
    updated_products = original_products.copy()
    
    <span class="comment"># Update an existing product</span>
    updated_products[<span class="number">0</span>][<span class="string">"price"</span>] = <span class="number">69.99</span>  <span class="comment"># Price drop</span>
    updated_products[<span class="number">0</span>][<span class="string">"availability"</span>] = <span class="keyword">False</span>  <span class="comment"># Out of stock</span>
    
    <span class="comment"># Add a new product</span>
    new_product = {
        <span class="string">"product_id"</span>: <span class="string">"P1004"</span>,
        <span class="string">"name"</span>: <span class="string">"Wireless Charging Pad"</span>,
        <span class="string">"category"</span>: <span class="string">"Electronics > Accessories > Chargers"</span>,
        <span class="string">"brand"</span>: <span class="string">"ChargeTech"</span>,
        <span class="string">"price"</span>: <span class="number">29.99</span>,
        <span class="string">"description"</span>: <span class="string">"Fast wireless charging pad compatible with all Qi-enabled devices. Features LED indicator and foreign object detection."</span>,
        <span class="string">"features"</span>: [<span class="string">"Wireless Charging"</span>, <span class="string">"Fast Charging"</span>, <span class="string">"LED Indicator"</span>],
        <span class="string">"specifications"</span>: {
            <span class="string">"charging_power"</span>: <span class="string">"15W"</span>,
            <span class="string">"compatibility"</span>: <span class="string">"Qi-enabled devices"</span>,
            <span class="string">"dimensions"</span>: <span class="string">"100mm x 100mm x 8mm"</span>,
            <span class="string">"weight"</span>: <span class="string">"80g"</span>
        },
        <span class="string">"availability"</span>: <span class="keyword">True</span>,
        <span class="string">"rating"</span>: <span class="number">4.2</span>,
        <span class="string">"reviews_count"</span>: <span class="number">320</span>
    }
    updated_products.append(new_product)
    
    <span class="comment"># Remove a product (simulate discontinuation)</span>
    updated_products.pop(<span class="number">2</span>)  <span class="comment"># Remove the TV</span>
    
    <span class="comment"># Create updated documents</span>
    updated_documents = create_product_documents(updated_products)
    
    <span class="comment"># Update the index</span>
    result = index.from_documents(
        updated_documents,
        cleanup=<span class="string">"incremental"</span>,
        source_id_key=<span class="string">"product_id"</span>
    )
    
    print(<span class="string">"Update Results:"</span>)
    print(<span class="string">f"Number of documents added: {len(result['added'])}"</span>)
    print(<span class="string">f"Number of documents updated: {len(result['updated'])}"</span>)
    print(<span class="string">f"Number of documents deleted: {len(result['deleted'])}"</span>)
    print(<span class="string">f"Number of documents skipped: {len(result['skipped'])}"</span>)
    
    <span class="keyword">return</span> updated_products

<span class="comment"># Function to demonstrate product search</span>
<span class="keyword">def</span> <span class="function">demonstrate_product_search</span>(index):
    <span class="string">"""Demonstrate product search using the indexed data."""</span>
    print(<span class="string">"\n=== Product Search Demo ===\n"</span>)
    
    <span class="comment"># Get the retriever from the index</span>
    retriever = index.vectorstore.as_retriever(search_kwargs={<span class="string">"k"</span>: <span class="number">3</span>})
    
    <span class="comment"># Example search queries</span>
    queries = [
        <span class="string">"Wireless headphones under $100"</span>,
        <span class="string">"Fitness tracker with heart rate monitor"</span>,
        <span class="string">"Charging accessories for smartphones"</span>
    ]
    
    <span class="keyword">for</span> query <span class="keyword">in</span> queries:
        print(<span class="string">f"Query: {query}\n"</span>)
        
        <span class="comment"># Retrieve relevant products</span>
        results = retriever.invoke(query)
        
        print(<span class="string">"Search Results:"</span>)
        <span class="keyword">for</span> i, doc <span class="keyword">in</span> enumerate(results, <span class="number">1</span>):
            print(<span class="string">f"{i}. {doc.metadata['name']} - ${doc.metadata['price']}"</span>)
            print(<span class="string">f"   Brand: {doc.metadata['brand']}"</span>)
            print(<span class="string">f"   Category: {doc.metadata['category']}"</span>)
            print(<span class="string">f"   Rating: {doc.metadata['rating']}/5"</span>)
            print(<span class="string">f"   Available: {'Yes' if doc.metadata['availability'] else 'No'}\n"</span>)

<span class="comment"># Function to demonstrate filtering by metadata</span>
<span class="keyword">def</span> <span class="function">demonstrate_metadata_filtering</span>(index):
    <span class="string">"""Demonstrate filtering products by metadata attributes."""</span>
    print(<span class="string">"\n=== Metadata Filtering Demo ===\n"</span>)
    
    <span class="comment"># Get the vector store</span>
    vectorstore = index.vectorstore
    
    <span class="comment"># Example filters</span>
    filters = [
        {<span class="string">"brand"</span>: <span class="string">"AudioTech"</span>},
        {<span class="string">"category"</span>: <span class="string">"Electronics > Wearables > Smartwatches"</span>},
        {<span class="string">"price"</span>: {<span class="string">"$lte"</span>: <span class="number">100</span>}},
        {<span class="string">"features"</span>: {<span class="string">"$in"</span>: [<span class="string">"Wireless"</span>, <span class="string">"Bluetooth"</span>]}}
    ]
    
    <span class="keyword">for</span> i, filter_dict <span class="keyword">in</span> enumerate(filters, <span class="number">1</span>):
        print(<span class="string">f"Filter {i}: {filter_dict}\n"</span>)
        
        <span class="comment"># Search with filter</span>
        results = vectorstore.similarity_search(
            <span class="string">"electronics"</span>, 
            k=<span class="number">5</span>, 
            filter=filter_dict
        )
        
        print(<span class="string">"Filtered Results:"</span>)
        <span class="keyword">for</span> j, doc <span class="keyword">in</span> enumerate(results, <span class="number">1</span>):
            print(<span class="string">f"{j}. {doc.metadata['name']} - ${doc.metadata['price']}"</span>)
            print(<span class="string">f"   Brand: {doc.metadata['brand']}"</span>)
            print(<span class="string">f"   Category: {doc.metadata['category']}\n"</span>)

<span class="comment"># Main execution</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Create product documents</span>
    product_documents = create_product_documents(product_data)
    
    <span class="comment"># Demonstrate indexing with record manager</span>
    product_index = demonstrate_indexing_with_record_manager(product_documents)
    
    <span class="comment"># Demonstrate index updates</span>
    updated_products = demonstrate_index_updates(product_index, product_data)
    
    <span class="comment"># Demonstrate product search</span>
    demonstrate_product_search(product_index)
    
    <span class="comment"># Demonstrate metadata filtering</span>
    demonstrate_metadata_filtering(product_index)</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="tools">
                <div class="card">
                    <div class="component-title">
                        <div class="icon">10</div>
                        Tools
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In finance, tools enable AI agents to interact with external systems like banking APIs, stock market data feeds, and financial databases. For example, a financial advisory agent might use tools to check account balances, retrieve stock prices, execute trades, and analyze market trends to provide personalized investment advice.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Tools solve the challenge of connecting AI agents to real-world systems and data sources. They provide a structured way for agents to interact with APIs, databases, and other external resources, enabling them to perform actions beyond text generation, such as retrieving live data, updating records, and executing transactions.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without tools, financial AI agents would be limited to providing generic advice based on their training data, unable to access real-time information or perform actual financial transactions. This would severely limit their usefulness for tasks like portfolio management, trading, and personalized financial planning.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Custom</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Execution</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Tools in LangChain are functions that agents can call to perform specific actions or retrieve information. They are defined with a name, description, and schema, and can be integrated with agents through the AgentExecutor. Tools can be simple Python functions or complex integrations with external APIs.
                        </p>
                        
                        <div class="business-example">
                            <strong>Finance Implementation:</strong> Building a financial advisory agent with tools:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">financial_tools.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_core.tools <span class="keyword">import</span> tool
<span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentExecutor, create_openai_tools_agent
<span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> AIMessageChunk, HumanMessage
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser
<span class="keyword">from</span> typing <span class="keyword">import</span> List, Dict, Optional
<span class="keyword">import</span> requests
<span class="keyword">import</span> json
<span class="keyword">import</span> os

<span class="comment"># Mock financial data</span>
account_balances = {
    <span class="string">"ACC12345"</span>: {<span class="string">"checking"</span>: <span class="number">5420.75</span>, <span class="string">"savings"</span>: <span class="number">12500.50</span>},
    <span class="string">"ACC67890"</span>: {<span class="string">"checking"</span>: <span class="number">3200.25</span>, <span class="string">"savings"</span>: <span class="number">8500.00</span>}
}

stock_prices = {
    <span class="string">"AAPL"</span>: {<span class="string">"price"</span>: <span class="number">182.63</span>, <span class="string">"change"</span>: <span class="number">1.25</span>, <span class="string">"change_percent"</span>: <span class="number">0.69</span>},
    <span class="string">"MSFT"</span>: {<span class="string">"price"</span>: <span class="number">340.54</span>, <span class="string">"change"</span>: <span class="number">-2.15</span>, <span class="string">"change_percent"</span>: <span class="number">-0.63</span>},
    <span class="string">"GOOGL"</span>: {<span class="string">"price"</span>: <span class="number">138.21</span>, <span class="string">"change"</span>: <span class="number">0.87</span>, <span class="string">"change_percent"</span>: <span class="number">0.63</span>},
    <span class="string">"AMZN"</span>: {<span class="string">"price"</span>: <span class="number">178.22</span>, <span class="string">"change"</span>: <span class="number">-1.33</span>, <span class="string">"change_percent"</span>: <span class="number">-0.74</span>}
}

portfolio_holdings = {
    <span class="string">"ACC12345"</span>: [
        {<span class="string">"symbol"</span>: <span class="string">"AAPL"</span>, <span class="string">"shares"</span>: <span class="number">10</span>, <span class="string">"purchase_price"</span>: <span class="number">175.50</span>},
        {<span class="string">"symbol"</span>: <span class="string">"MSFT"</span>, <span class="string">"shares"</span>: <span class="number">5</span>, <span class="string">"purchase_price"</span>: <span class="number">330.25</span>}
    ],
    <span class="string">"ACC67890"</span>: [
        {<span class="string">"symbol"</span>: <span class="string">"GOOGL"</span>, <span class="string">"shares"</span>: <span class="number">15</span>, <span class="string">"purchase_price"</span>: <span class="number">135.75</span>},
        {<span class="string">"symbol"</span>: <span class="string">"AMZN"</span>, <span class="string">"shares"</span>: <span class="number">8</span>, <span class="string">"purchase_price"</span>: <span class="number">185.00</span>}
    ]
}

<span class="comment"># Define financial tools</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">get_account_balance</span>(account_id: str) -> str:
    <span class="string">"""Get the account balance for a given account ID."""</span>
    <span class="keyword">if</span> account_id <span class="keyword">in</span> account_balances:
        balances = account_balances[account_id]
        checking = balances[<span class="string">"checking"</span>]
        savings = balances[<span class="string">"savings"</span>]
        total = checking + savings
        <span class="keyword">return</span> f<span class="string">"Account {account_id}: Checking: ${checking:.2f}, Savings: ${savings:.2f}, Total: ${total:.2f}"</span>
    <span class="keyword">else</span>:
        <span class="keyword">return</span> f<span class="string">"Account {account_id} not found."</span>

<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">get_stock_price</span>(symbol: str) -> str:
    <span class="string">"""Get the current stock price for a given symbol."""</span>
    symbol = symbol.upper()
    <span class="keyword">if</span> symbol <span class="keyword">in</span> stock_prices:
        data = stock_prices[symbol]
        price = data[<span class="string">"price"</span>]
        change = data[<span class="string">"change"</span>]
        change_percent = data[<span class="string">"change_percent"</span>]
        direction = <span class="string">"↑"</span> <span class="keyword">if</span> change >= <span class="number">0</span> <span class="keyword">else</span> <span class="string">"↓"</span>
        <span class="keyword">return</span> f<span class="string">"{symbol}: ${price:.2f} {direction}{abs(change):.2f} ({abs(change_percent):.2f}%)"</span>
    <span class="keyword">else</span>:
        <span class="keyword">return</span> f<span class="string">"Stock symbol {symbol} not found."</span>

<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">get_portfolio</span>(account_id: str) -> str:
    <span class="string">"""Get the portfolio holdings for a given account ID."""</span>
    <span class="keyword">if</span> account_id <span class="keyword">in</span> portfolio_holdings:
        holdings = portfolio_holdings[account_id]
        result = f<span class="string">"Portfolio for account {account_id}:\n"</span>
        total_value = <span class="number">0</span>
        total_cost = <span class="number">0</span>
        
        <span class="keyword">for</span> holding <span class="keyword">in</span> holdings:
            symbol = holding[<span class="string">"symbol"</span>]
            shares = holding[<span class="string">"shares"</span>]
            purchase_price = holding[<span class="string">"purchase_price"</span>]
            
            <span class="keyword">if</span> symbol <span class="keyword">in</span> stock_prices:
                current_price = stock_prices[symbol][<span class="string">"price"</span>]
                value = shares * current_price
                cost = shares * purchase_price
                gain_loss = value - cost
                gain_loss_percent = (gain_loss / cost) * <span class="number">100</span>
                
                result += f<span class="string">"- {symbol}: {shares} shares @ ${purchase_price:.2f} → ${current_price:.2f}\n"</span>
                result += f<span class="string">"  Value: ${value:.2f}, Cost: ${cost:.2f}, Gain/Loss: ${gain_loss:+.2f} ({gain_loss_percent:+.2f}%)\n"</span>
                
                total_value += value
                total_cost += cost
            <span class="keyword">else</span>:
                result += f<span class="string">"- {symbol}: {shares} shares @ ${purchase_price:.2f} (price data unavailable)\n"</span>
                total_cost += shares * purchase_price
        
        total_gain_loss = total_value - total_cost
        total_gain_loss_percent = (total_gain_loss / total_cost) * <span class="number">100</span> <span class="keyword">if</span> total_cost > <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>
        
        result += f<span class="string">"\nTotal Portfolio Value: ${total_value:.2f}\n"</span>
        result += f<span class="string">"Total Cost: ${total_cost:.2f}\n"</span>
        result += f<span class="string">"Total Gain/Loss: ${total_gain_loss:+.2f} ({total_gain_loss_percent:+.2f}%)"</span>
        
        <span class="keyword">return</span> result
    <span class="keyword">else</span>:
        <span class="keyword">return</span> f<span class="string">"No portfolio found for account {account_id}."</span>

<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">transfer_funds</span>(account_id: str, from_account: str, to_account: str, amount: float) -> str:
    <span class="string">"""Transfer funds between accounts for a given customer."""</span>
    <span class="keyword">if</span> account_id <span class="keyword">not</span> <span class="keyword">in</span> account_balances:
        <span class="keyword">return</span> f<span class="string">"Account {account_id} not found."</span>
    
    balances = account_balances[account_id]
    
    <span class="keyword">if</span> from_account <span class="keyword">not</span> <span class="keyword">in</span> balances:
        <span class="keyword">return</span> f<span class="string">"Source account '{from_account}' not found."</span>
    
    <span class="keyword">if</span> to_account <span class="keyword">not</span> <span class="keyword">in</span> balances:
        <span class="keyword">return</span> f<span class="string">"Destination account '{to_account}' not found."</span>
    
    <span class="keyword">if</span> balances[from_account] < amount:
        <span class="keyword">return</span> f<span class="string">"Insufficient funds in {from_account}. Available: ${balances[from_account]:.2f}, Required: ${amount:.2f}"</span>
    
    <span class="comment"># Perform the transfer</span>
    balances[from_account] -= amount
    balances[to_account] += amount
    
    <span class="keyword">return</span> f<span class="string">"Successfully transferred ${amount:.2f} from {from_account} to {to_account} for account {account_id}.\n"</span> \
           f<span class="string">"New balances: {from_account}: ${balances[from_account]:.2f}, {to_account}: ${balances[to_account]:.2f}"</span>

<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">execute_trade</span>(account_id: str, symbol: str, action: str, shares: int) -> str:
    <span class="string">"""Execute a trade (buy or sell) for a given account."""</span>
    symbol = symbol.upper()
    action = action.lower()
    
    <span class="keyword">if</span> account_id <span class="keyword">not</span> <span class="keyword">in</span> account_balances:
        <span class="keyword">return</span> f<span class="string">"Account {account_id} not found."</span>
    
    <span class="keyword">if</span> symbol <span class="keyword">not</span> <span class="keyword">in</span> stock_prices:
        <span class="keyword">return</span> f<span class="string">"Stock symbol {symbol} not found."</span>
    
    <span class="keyword">if</span> action <span class="keyword">not</span> [<span class="string">"buy"</span>, <span class="string">"sell"</span>]:
        <span class="keyword">return</span> f<span class="string">"Invalid action '{action}'. Must be 'buy' or 'sell'."</span>
    
    price = stock_prices[symbol][<span class="string">"price"</span>]
    total_cost = shares * price
    
    <span class="keyword">if</span> action == <span class="string">"buy"</span>:
        <span class="comment"># Check if enough funds in checking account</span>
        checking_balance = account_balances[account_id][<span class="string">"checking"</span>]
        
        <span class="keyword">if</span> checking_balance < total_cost:
            <span class="keyword">return</span> f<span class="string">"Insufficient funds to buy {shares} shares of {symbol}. Required: ${total_cost:.2f}, Available: ${checking_balance:.2f}"</span>
        
        <span class="comment"># Execute buy order</span>
        account_balances[account_id][<span class="string">"checking"</span>] -= total_cost
        
        <span class="comment"># Add to portfolio</span>
        <span class="keyword">if</span> account_id <span class="keyword">not</span> <span class="keyword">in</span> portfolio_holdings:
            portfolio_holdings[account_id] = []
        
        <span class="comment"># Check if already holding this stock</span>
        existing_holding = <span class="keyword">None</span>
        <span class="keyword">for</span> holding <span class="keyword">in</span> portfolio_holdings[account_id]:
            <span class="keyword">if</span> holding[<span class="string">"symbol"</span>] == symbol:
                existing_holding = holding
                <span class="keyword">break</span>
        
        <span class="keyword">if</span> existing_holding:
            <span class="comment"># Update existing holding</span>
            old_shares = existing_holding[<span class="string">"shares"</span>]
            old_cost = existing_holding[<span class="string">"purchase_price"</span>] * old_shares
            new_shares = old_shares + shares
            new_cost = old_cost + total_cost
            existing_holding[<span class="string">"shares"</span>] = new_shares
            existing_holding[<span class="string">"purchase_price"</span>] = new_cost / new_shares
        <span class="keyword">else</span>:
            <span class="comment"># Add new holding</span>
            portfolio_holdings[account_id].append({
                <span class="string">"symbol"</span>: symbol,
                <span class="string">"shares"</span>: shares,
                <span class="string">"purchase_price"</span>: price
            })
        
        <span class="keyword">return</span> f<span class="string">"Successfully bought {shares} shares of {symbol} at ${price:.2f} per share. Total cost: ${total_cost:.2f}."</span>
    
    <span class="keyword">else</span>:  <span class="comment"># Sell</span>
        <span class="comment"># Check if holding this stock</span>
        <span class="keyword">if</span> account_id <span class="keyword">not</span> <span class="keyword">in</span> portfolio_holdings:
            <span class="keyword">return</span> f<span class="string">"No holdings found for account {account_id}."</span>
        
        holding_found = <span class="keyword">False</span>
        <span class="keyword">for</span> holding <span class="keyword">in</span> portfolio_holdings[account_id]:
            <span class="keyword">if</span> holding[<span class="string">"symbol"</span>] == symbol:
                holding_found = <span class="keyword">True</span>
                
                <span class="keyword">if</span> holding[<span class="string">"shares"</span>] < shares:
                    <span class="keyword">return</span> f<span class="string">"Insufficient shares to sell. Available: {holding['shares']}, Requested: {shares}"</span>
                
                <span class="comment"># Execute sell order</span>
                account_balances[account_id][<span class="string">"checking"</span>] += total_cost
                
                <span class="keyword">if</span> holding[<span class="string">"shares"</span>] == shares:
                    <span class="comment"># Remove the holding entirely</span>
                    portfolio_holdings[account_id].remove(holding)
                <span class="keyword">else</span>:
                    <span class="comment"># Reduce the number of shares</span>
                    holding[<span class="string">"shares"</span>] -= shares
                
                <span class="keyword">break</span>
        
        <span class="keyword">if</span> <span class="keyword">not</span> holding_found:
            <span class="keyword">return</span> f<span class="string">"No holdings of {symbol} found for account {account_id}."</span>
        
        <span class="keyword">return</span> f<span class="string">"Successfully sold {shares} shares of {symbol} at ${price:.2f} per share. Total value: ${total_cost:.2f}."</span>

<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">get_market_news</span>(query: str = <span class="string">""</span>) -> str:
    <span class="string">"""Get the latest financial market news, optionally filtered by a query."""</span>
    <span class="comment"># In a real implementation, this would call a financial news API</span>
    <span class="comment"># Here we simulate with mock news data</span>
    
    news_items = [
        {
            <span class="string">"headline"</span>: <span class="string">"Fed Signals Potential Rate Pause Amid Economic Uncertainty"</span>,
            <span class="string">"summary"</span>: <span class="string">"The Federal Reserve indicated it may pause interest rate hikes as economic data shows signs of slowing inflation."</span>,
            <span class="string">"source"</span>: <span class="string">"Financial Times"</span>,
            <span class="string">"timestamp"</span>: <span class="string">"2023-06-15 10:30:00"</span>
        },
        {
            <span class="string">"headline"</span>: <span class="string">"Tech Stocks Rally on AI Optimism"</span>,
            <span class="string">"summary"</span>: <span class="string">"Major technology companies saw gains as investors expressed optimism about artificial intelligence advancements."</span>,
            <span class="string">"source"</span>: <span class="string">"Bloomberg"</span>,
            <span class="string">"timestamp"</span>: <span class="string">"2023-06-15 09:45:00"</span>
        },
        {
            <span class="string">"headline"</span>: <span class="string">"Oil Prices Surge on Supply Concerns"</span>,
            <span class="string">"summary"</span>: <span class="string">"Crude oil prices jumped 3% amid concerns about potential supply disruptions in the Middle East."</span>,
            <span class="string">"source"</span>: <span class="string">"Reuters"</span>,
            <span class="string">"timestamp"</span>: <span class="string">"2023-06-15 08:15:00"</span>
        }
    ]
    
    <span class="comment"># Filter by query if provided</span>
    <span class="keyword">if</span> query:
        query_lower = query.lower()
        filtered_news = []
        <span class="keyword">for</span> item <span class="keyword">in</span> news_items:
            <span class="keyword">if</span> query_lower <span class="keyword">in</span> item[<span class="string">"headline"</span>].lower() <span class="keyword">or</span> query_lower <span class="keyword">in</span> item[<span class="string">"summary"</span>].lower():
                filtered_news.append(item)
        news_items = filtered_news
    
    <span class="keyword">if</span> <span class="keyword">not</span> news_items:
        <span class="keyword">return</span> f<span class="string">"No news found matching query: {query}"</span>
    
    result = <span class="string">"Latest Financial News:\n\n"</span>
    <span class="keyword">for</span> item <span class="keyword">in</span> news_items:
        result += f<span class="string">"- {item['headline']}\n"</span>
        result += f<span class="string">"  {item['summary']}\n"</span>
        result += f<span class="string">"  Source: {item['source']}, {item['timestamp']}\n\n"</span>
    
    <span class="keyword">return</span> result

<span class="comment"># List of tools</span>
tools = [
    get_account_balance,
    get_stock_price,
    get_portfolio,
    transfer_funds,
    execute_trade,
    get_market_news
]

<span class="comment"># Initialize the language model</span>
llm = ChatOpenAI(model=<span class="string">"gpt-4-turbo"</span>, temperature=<span class="number">0.2</span>)

<span class="comment"># Create a prompt template</span>
prompt = ChatPromptTemplate.from_messages([
    (<span class="string">"system"</span>, <span class="string">"""
    You are a helpful financial assistant AI. Your goal is to help customers with their banking and investment needs.
    Use the tools available to you to provide accurate and up-to-date financial information.
    Always be clear about the limitations of your advice and remind customers that investing involves risk.
    Never make specific investment recommendations without understanding the customer's full financial situation.
    """</span>),
    MessagesPlaceholder(variable_name=<span class="string">"chat_history"</span>),
    (<span class="string">"human"</span>, <span class="string">"{input}"</span>),
    MessagesPlaceholder(variable_name=<span class="string">"agent_scratchpad"</span>),
])

<span class="comment"># Create the agent</span>
agent = create_openai_tools_agent(llm, tools, prompt)

<span class="comment"># Create the agent executor</span>
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=<span class="keyword">True</span>,
    max_iterations=<span class="number">10</span>,
    early_stopping_method=<span class="string">"generate"</span>
)

<span class="comment"># Function to interact with the financial assistant</span>
<span class="keyword">def</span> <span class="function">financial_assistant</span>(input_text, chat_history=None):
    <span class="keyword">if</span> chat_history <span class="keyword">is</span> <span class="keyword">None</span>:
        chat_history = []
    
    result = agent_executor.invoke({
        <span class="string">"input"</span>: input_text,
        <span class="string">"chat_history"</span>: chat_history
    })
    
    <span class="keyword">return</span> result[<span class="string">'output'</span>]

<span class="comment"># Example usage</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Example 1: Check account balance</span>
    response1 = financial_assistant(<span class="string">"What's my account balance for ACC12345?"</span>)
    print(<span class="string">"Response 1:"</span>)
    print(response1)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 2: Get stock prices</span>
    response2 = financial_assistant(<span class="string">"What are the current prices for AAPL and MSFT?"</span>)
    print(<span class="string">"Response 2:"</span>)
    print(response2)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 3: Get portfolio</span>
    response3 = financial_assistant(<span class="string">"Show me my portfolio for account ACC12345"</span>)
    print(<span class="string">"Response 3:"</span>)
    print(response3)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 4: Execute a trade</span>
    response4 = financial_assistant(<span class="string">"Buy 5 shares of GOOGL for account ACC12345"</span>)
    print(<span class="string">"Response 4:"</span>)
    print(response4)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 5: Get market news</span>
    response5 = financial_assistant(<span class="string">"What's the latest news about tech stocks?"</span>)
    print(<span class="string">"Response 5:"</span>)
    print(response5)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 6: Transfer funds</span>
    response6 = financial_assistant(<span class="string">"Transfer $1000 from checking to savings for account ACC12345"</span>)
    print(<span class="string">"Response 6:"</span>)
    print(response6)</code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="component-title">
                        <div class="icon">11</div>
                        Multimodal
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In healthcare, multimodal AI enables diagnostic systems that can analyze both medical images (X-rays, MRIs, CT scans) and patient records to provide comprehensive diagnoses. For example, a radiology department might use a multimodal system that analyzes X-ray images while also considering patient history, symptoms, and lab results to detect conditions like pneumonia or fractures.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Multimodal AI solves the challenge of integrating and analyzing different types of data (text, images, audio, etc.) to make more informed decisions. It enables systems to understand the relationships between different data modalities, leading to more accurate and comprehensive insights than single-modality approaches.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without multimodal capabilities, healthcare systems would need to analyze different data types separately, potentially missing important correlations between visual findings and clinical data. This could lead to incomplete diagnoses, missed conditions, and suboptimal treatment plans, ultimately affecting patient outcomes.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Custom</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Interface</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Multimodal AI in LangChain involves processing and integrating different types of data (text, images, audio, etc.) through specialized models and tools. It requires careful coordination of different modalities, alignment of features across data types, and fusion techniques to combine information effectively.
                        </p>
                        
                        <div class="business-example">
                            <strong>Healthcare Implementation:</strong> Building a multimodal diagnostic system:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">healthcare_multimodal.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_core.tools <span class="keyword">import</span> tool
<span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentExecutor, create_openai_tools_agent
<span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage, AIMessage
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document
<span class="keyword">from</span> PIL <span class="keyword">import</span> Image
<span class="keyword">import</span> requests
<span class="keyword">import</span> io
<span class="keyword">import</span> base64
<span class="keyword">import</span> os
<span class="keyword">import</span> json

<span class="comment"># Initialize the language model with vision capabilities</span>
llm = ChatOpenAI(model=<span class="string">"gpt-4-vision-preview"</span>, temperature=<span class="number">0.2</span>, max_tokens=<span class="number">1000</span>)

<span class="comment"># Mock patient data</span>
patient_records = {
    <span class="string">"P12345"</span>: {
        <span class="string">"name"</span>: <span class="string">"John Doe"</span>,
        <span class="string">"age"</span>: <span class="number">45</span>,
        <span class="string">"gender"</span>: <span class="string">"Male"</span>,
        <span class="string">"medical_history"</span>: [
            <span class="string">"Hypertension (diagnosed 2018)"</span>,
            <span class="string">"Type 2 Diabetes (diagnosed 2020)"</span>,
            <span class="string">"Appendectomy (2015)"</span>
        ],
        <span class="string">"medications"</span>: [
            <span class="string">"Lisinopril 10mg daily"</span>,
            <span class="string">"Metformin 500mg twice daily"</span>
        ],
        <span class="string">"allergies"</span>: [
            <span class="string">"Penicillin"</span>,
            <span class="string">"Sulfa drugs"</span>
        ],
        <span class="string">"recent_lab_results"</span>: {
            <span class="string">"glucose"</span>: <span class="string">"145 mg/dL"</span>,
            <span class="string">"HbA1c"</span>: <span class="string">"7.2%"</span>,
            <span class="string">"blood_pressure"</span>: <span class="string">"140/90 mmHg"</span>
        }
    },
    <span class="string">"P67890"</span>: {
        <span class="string">"name"</span>: <span class="string">"Jane Smith"</span>,
        <span class="string">"age"</span>: <span class="number">32</span>,
        <span class="string">"gender"</span>: <span class="string">"Female"</span>,
        <span class="string">"medical_history"</span>: [
            <span class="string">"Asthma (diagnosed 2010)"</span>,
            <span class="string">"Migraines (diagnosed 2015)"</span>
        ],
        <span class="string">"medications"</span>: [
            <span class="string">"Albuterol inhaler as needed"</span>,
            <span class="string">"Sumatriptan 50mg as needed for migraines"</span>
        ],
        <span class="string">"allergies"</span>: [
            <span class="string">"None known"</span>
        ],
        <span class="string">"recent_lab_results"</span>: {
            <span class="string">"glucose"</span>: <span class="string">"92 mg/dL"</span>,
            <span class="string">"HbA1c"</span>: <span class="string">"5.4%"</span>,
            <span class="string">"blood_pressure"</span>: <span class="string">"118/76 mmHg"</span>
        }
    }
}

<span class="comment"># Function to encode image to base64</span>
<span class="keyword">def</span> <span class="function">encode_image</span>(image_path):
    <span class="string">"""Encode an image file to base64 string."""</span>
    <span class="keyword">with</span> open(image_path, <span class="string">"rb"</span>) <span class="keyword">as</span> image_file:
        <span class="keyword">return</span> base64.b64encode(image_file.read()).decode(<span class="string">'utf-8'</span>)

<span class="comment"># Function to analyze medical image</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">analyze_medical_image</span>(image_path: str, image_type: str) -> str:
    <span class="string">"""Analyze a medical image using vision capabilities."""</span>
    <span class="comment"># Get the base64 string</span>
    base64_image = encode_image(image_path)
    
    <span class="comment"># Create a prompt for image analysis</span>
    image_prompt = f<span class="string">"""
    You are a medical imaging specialist. Analyze this {image_type} image and provide:
    1. A detailed description of what you see
    2. Any potential abnormalities or areas of concern
    3. Possible diagnoses based on the image
    4. Recommendations for further testing or follow-up
    
    Be thorough in your analysis but remember that this is not a substitute for a professional medical diagnosis.
    """</span>
    
    <span class="comment"># Create a message with the image</span>
    message = HumanMessage(
        content=[
            {<span class="string">"type"</span>: <span class="string">"text"</span>, <span class="string">"text"</span>: image_prompt},
            {
                <span class="string">"type"</span>: <span class="string">"image_url"</span>,
                <span class="string">"image_url"</span>: {
                    <span class="string">"url"</span>: f<span class="string">"data:image/jpeg;base64,{base64_image}"</span>
                }
            }
        ]
    )
    
    <span class="comment"># Get the analysis from the model</span>
    response = llm.invoke([message])
    
    <span class="keyword">return</span> response.content

<span class="comment"># Function to retrieve patient records</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">get_patient_record</span>(patient_id: str) -> str:
    <span class="string">"""Retrieve patient record by ID."""</span>
    <span class="keyword">if</span> patient_id <span class="keyword">in</span> patient_records:
        record = patient_records[patient_id]
        
        <span class="comment"># Format the record as a readable string</span>
        formatted_record = f<span class="string">"""
        Patient: {record['name']}, {record['age']}-year-old {record['gender']}
        
        Medical History:
        {chr(10).join(f"- {item}" for item in record['medical_history'])}
        
        Current Medications:
        {chr(10).join(f"- {item}" for item in record['medications'])}
        
        Allergies:
        {chr(10).join(f"- {item}" for item in record['allergies'])}
        
        Recent Lab Results:
        """</span>
        
        <span class="keyword">for</span> test, result <span class="keyword">in</span> record[<span class="string">"recent_lab_results"</span>].items():
            formatted_record += f<span class="string">"- {test.replace('_', ' ').title()}: {result}\n"</span>
        
        <span class="keyword">return</span> formatted_record
    <span class="keyword">else</span>:
        <span class="keyword">return</span> f<span class="string">"Patient record with ID {patient_id} not found."</span>

<span class="comment"># Function to search medical literature</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">search_medical_literature</span>(query: str) -> str:
    <span class="string">"""Search medical literature for relevant information."""</span>
    <span class="comment"># In a real implementation, this would connect to a medical database</span>
    <span class="comment"># Here we simulate with a predefined knowledge base</span>
    
    medical_knowledge = [
        Document(
            page_content=<span class="string">"Pneumonia is an infection that inflames the air sacs in one or both lungs. The air sacs may fill with fluid or pus, causing cough with phlegm or pus, fever, chills, and difficulty breathing. Pneumonia can be caused by bacteria, viruses, or fungi. Diagnosis is typically based on symptoms and physical examination, confirmed by chest X-ray. Treatment depends on the cause but may include antibiotics, antiviral medications, or antifungal medications."</span>,
            metadata={<span class="string">"source"</span>: <span class="string">"Medical Encyclopedia"</span>, <span class="string">"condition"</span>: <span class="string">"Pneumonia"</span>}
        ),
        Document(
            page_content=<span class="string">"A bone fracture is a medical condition where the continuity of the bone is broken. Symptoms include pain, swelling, bruising, and inability to move the affected area. Diagnosis is typically made through X-rays, CT scans, or MRI. Treatment depends on the type and severity of the fracture but may include immobilization with a cast or splint, traction, or surgery to realign the bone."</span>,
            metadata={<span class="string">"source"</span>: <span class="string">"Medical Encyclopedia"</span>, <span class="string">"condition"</span>: <span class="string">"Bone Fracture"</span>}
        ),
        Document(
            page_content=<span class="string">"Diabetes mellitus is a group of metabolic disorders characterized by high blood sugar levels over a prolonged period. Symptoms include frequent urination, increased thirst, and increased hunger. Acute complications include diabetic ketoacidosis, hyperosmolar hyperglycemic state, or death. Serious long-term complications include cardiovascular disease, stroke, chronic kidney disease, foot ulcers, and damage to the eyes."</span>,
            metadata={<span class="string">"source"</span>: <span class="string">"Medical Encyclopedia"</span>, <span class="string">"condition"</span>: <span class="string">"Diabetes"</span>}
        )
    ]
    
    <span class="comment"># Create a simple vector store for search</span>
    embeddings = OpenAIEmbeddings()
    vectorstore = Chroma.from_documents(medical_knowledge, embeddings)
    
    <span class="comment"># Search for relevant documents</span>
    results = vectorstore.similarity_search(query, k=<span class="number">2</span>)
    
    <span class="keyword">if</span> results:
        response = <span class="string">"Relevant Medical Information:\n\n"</span>
        <span class="keyword">for</span> doc <span class="keyword">in</span> results:
            response += f<span class="string">"{doc.page_content}\n\n"</span>
        <span class="keyword">return</span> response
    <span class="keyword">else</span>:
        <span class="keyword">return</span> f<span class="string">"No relevant medical information found for query: {query}"</span>

<span class="comment"># Function to generate diagnostic report</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">generate_diagnostic_report</span>(patient_id: str, image_analysis: str, patient_data: str, literature: str) -> str:
    <span class="string">"""Generate a comprehensive diagnostic report based on multimodal analysis."""</span>
    
    <span class="comment"># Create a prompt for report generation</span>
    report_prompt = f<span class="string">"""
    You are a medical professional generating a diagnostic report based on multimodal analysis.
    
    Patient ID: {patient_id}
    
    Patient Data:
    {patient_data}
    
    Image Analysis:
    {image_analysis}
    
    Relevant Medical Literature:
    {literature}
    
    Based on all the information above, generate a comprehensive diagnostic report that includes:
    1. Summary of findings
    2. Potential diagnoses
    3. Recommended follow-up tests or procedures
    4. Treatment recommendations
    5. Any concerns or areas requiring immediate attention
    
    Remember that this is an AI-generated report and should be reviewed by a qualified medical professional.
    """</span>
    
    <span class="comment"># Generate the report</span>
    response = llm.invoke([HumanMessage(content=report_prompt)])
    
    <span class="keyword">return</span> response.content

<span class="comment"># List of tools</span>
tools = [
    analyze_medical_image,
    get_patient_record,
    search_medical_literature,
    generate_diagnostic_report
]

<span class="comment"># Create a prompt template</span>
prompt = ChatPromptTemplate.from_messages([
    (<span class="string">"system"</span>, <span class="string">"""
    You are a multimodal medical diagnostic assistant. Your goal is to help healthcare professionals by analyzing medical images,
    patient records, and medical literature to generate comprehensive diagnostic reports.
    
    When working with medical images, carefully analyze the visual information and correlate it with patient data.
    Always consider the patient's medical history, medications, allergies, and lab results when making assessments.
    
    Remember that your analysis is not a substitute for professional medical judgment and should be reviewed by qualified healthcare providers.
    """</span>),
    MessagesPlaceholder(variable_name=<span class="string">"chat_history"</span>),
    (<span class="string">"human"</span>, <span class="string">"{input}"</span>),
    MessagesPlaceholder(variable_name=<span class="string">"agent_scratchpad"</span>),
])

<span class="comment"># Create the agent</span>
agent = create_openai_tools_agent(llm, tools, prompt)

<span class="comment"># Create the agent executor</span>
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=<span class="keyword">True</span>,
    max_iterations=<span class="number">10</span>,
    early_stopping_method=<span class="string">"generate"</span>
)

<span class="comment"># Function to interact with the multimodal diagnostic assistant</span>
<span class="keyword">def</span> <span class="function">diagnostic_assistant</span>(input_text, chat_history=None):
    <span class="keyword">if</span> chat_history <span class="keyword">is</span> <span class="keyword">None</span>:
        chat_history = []
    
    result = agent_executor.invoke({
        <span class="string">"input"</span>: input_text,
        <span class="string">"chat_history"</span>: chat_history
    })
    
    <span class="keyword">return</span> result[<span class="string">'output'</span>]

<span class="comment"># Example usage</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Example 1: Analyze a chest X-ray</span>
    <span class="comment"># Note: In a real scenario, you would have actual medical images</span>
    <span class="comment"># For this example, we'll simulate the process</span>
    
    print(<span class="string">"=== Multimodal Medical Diagnostic System ===\n"</span>)
    
    <span class="comment"># Simulate analyzing a chest X-ray for patient P12345</span>
    <span class="comment"># In a real implementation, you would provide the actual image path</span>
    response1 = diagnostic_assistant(
        <span class="string">"Analyze the chest X-ray for patient P12345 and generate a diagnostic report. The patient is a 45-year-old male with hypertension and diabetes."</span>
    )
    
    print(<span class="string">"Response 1:"</span>)
    print(response1)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 2: Analyze a bone X-ray</span>
    response2 = diagnostic_assistant(
        <span class="string">"Analyze the arm X-ray for patient P67890 and check for fractures. The patient is a 32-year-old female with asthma who fell while hiking."</span>
    )
    
    print(<span class="string">"Response 2:"</span>)
    print(response2)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 3: Multimodal analysis with symptoms and image</span>
    response3 = diagnostic_assistant(
        <span class="string">"Patient P12345 presents with fever, cough, and difficulty breathing. Analyze the chest X-ray and generate a comprehensive diagnostic report considering the patient's medical history of hypertension and diabetes."</span>
    )
    
    print(<span class="string">"Response 3:"</span>)
    print(response3)</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="tab-content" id="advanced">
                <div class="card">
                    <div class="component-title">
                        <div class="icon">12</div>
                        Agents
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In retail, intelligent agents power personalized shopping assistants that can understand customer preferences, recommend products, and handle complex inquiries. For example, a fashion retailer might deploy an agent that helps customers find outfits based on their style preferences, body type, and budget, while also checking inventory and suggesting complementary items.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Agents solve the challenge of creating autonomous systems that can understand complex requests, make decisions, and take actions to achieve specific goals. They combine reasoning, memory, and tool usage to handle tasks that would otherwise require human intervention, enabling automation of complex workflows.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without intelligent agents, retailers would need to rely on simple rule-based systems or human customer service representatives, leading to less personalized experiences, slower response times, and higher operational costs. Customers would receive generic recommendations rather than personalized suggestions tailored to their preferences.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Custom</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Execution</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Agents in LangChain are autonomous systems that use language models to reason, decide on actions, and use tools to accomplish tasks. They follow a loop of thought, action, and observation, allowing them to handle complex, multi-step problems. Agents can be customized with different reasoning approaches, memory systems, and tool sets.
                        </p>
                        
                        <div class="business-example">
                            <strong>Retail Implementation:</strong> Building a personalized shopping assistant:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">retail_agent.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <div class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_core.tools <span class="keyword">import</span> tool
<span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentExecutor, create_openai_tools_agent
<span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage, AIMessage, SystemMessage
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser
<span class="keyword">from</span> langchain_community.vectorstores <span class="keyword">import</span> Chroma
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings
<span class="keyword">from</span> langchain_core.documents <span class="keyword">import</span> Document
<span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> RunnablePassthrough
<span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferMemory
<span class="keyword">from</span> langchain_core.runnables.history <span class="keyword">import</span> RunnableWithMessageHistory
<span class="keyword">from</span> langchain_core.chat_history <span class="keyword">import</span> BaseChatMessageHistory
<span class="keyword">from</span> langchain_community.chat_message_histories <span class="keyword">import</span> ChatMessageHistory
<span class="keyword">from</span> typing <span class="keyword">import</span> Dict, List
<span class="keyword">import</span> json
<span class="keyword">import</span> os

<span class="comment"># Initialize the language model</span>
llm = ChatOpenAI(model=<span class="string">"gpt-4-turbo"</span>, temperature=<span class="number">0.3</span>)

<span class="comment"># Mock product catalog</span>
product_catalog = [
    {
        <span class="string">"product_id"</span>: <span class="string">"P1001"</span>,
        <span class="string">"name"</span>: <span class="string">"Classic White T-Shirt"</span>,
        <span class="string">"category"</span>: <span class="string">"Tops > T-Shirts"</span>,
        <span class="string">"brand"</span>: <span class="string">"BasicsCo"</span>,
        <span class="string">"price"</span>: <span class="number">19.99</span>,
        <span class="string">"description"</span>: <span class="string">"Comfortable 100% cotton t-shirt in classic white. Perfect for everyday wear."</span>,
        <span class="string">"sizes"</span>: [<span class="string">"XS"</span>, <span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>],
        <span class="string">"colors"</span>: [<span class="string">"White"</span>, <span class="string">"Black"</span>, <span class="string">"Gray"</span>],
        <span class="string">"inventory"</span>: {
            <span class="string">"White"</span>: {<span class="string">"XS"</span>: <span class="number">15</span>, <span class="string">"S"</span>: <span class="number">25</span>, <span class="string">"M"</span>: <span class="number">30</span>, <span class="string">"L"</span>: <span class="number">20</span>, <span class="string">"XL"</span>: <span class="number">10</span>},
            <span class="string">"Black"</span>: {<span class="string">"XS"</span>: <span class="number">10</span>, <span class="string">"S"</span>: <span class="number">20</span>, <span class="string">"M"</span>: <span class="number">25</span>, <span class="string">"L"</span>: <span class="number">15</span>, <span class="string">"XL"</span>: <span class="number">5</span>},
            <span class="string">"Gray"</span>: {<span class="string">"XS"</span>: <span class="number">5</span>, <span class="string">"S"</span>: <span class="number">10</span>, <span class="string">"M"</span>: <span class="number">15</span>, <span class="string">"L"</span>: <span class="number">10</span>, <span class="string">"XL"</span>: <span class="number">5</span>}
        },
        <span class="string">"rating"</span>: <span class="number">4.5</span>,
        <span class="string">"reviews_count"</span>: <span class="number">320</span>,
        <span class="string">"tags"</span>: [<span class="string">"casual"</span>, <span class="string">"basic"</span>, <span class="string">"cotton"</span>, <span class="string">"versatile"</span>]
    },
    {
        <span class="string">"product_id"</span>: <span class="string">"P1002"</span>,
        <span class="string">"name"</span>: <span class="string">"Slim Fit Jeans"</span>,
        <span class="string">"category"</span>: <span class="string">"Bottoms > Jeans"</span>,
        <span class="string">"brand"</span>: <span class="string">"DenimCo"</span>,
        <span class="string">"price"</span>: <span class="number">49.99</span>,
        <span class="string">"description"</span>: <span class="string">"Modern slim fit jeans with stretch comfort. Available in multiple washes."</span>,
        <span class="string">"sizes"</span>: [<span class="string">"28"</span>, <span class="string">"30"</span>, <span class="string">"32"</span>, <span class="string">"34"</span>, <span class="string">"36"</span>],
        <span class="string">"colors"</span>: [<span class="string">"Light Blue"</span>, <span class="string">"Dark Blue"</span>, <span class="string">"Black"</span>],
        <span class="string">"inventory"</span>: {
            <span class="string">"Light Blue"</span>: {<span class="string">"28"</span>: <span class="number">10</span>, <span class="string">"30"</span>: <span class="number">15</span>, <span class="string">"32"</span>: <span class="number">20</span>, <span class="string">"34"</span>: <span class="number">15</span>, <span class="string">"36"</span>: <span class="number">10</span>},
            <span class="string">"Dark Blue"</span>: {<span class="string">"28"</span>: <span class="number">15</span>, <span class="string">"30"</span>: <span class="number">20</span>, <span class="string">"32"</span>: <span class="number">25</span>, <span class="string">"34"</span>: <span class="number">20</span>, <span class="string">"36"</span>: <span class="number">15</span>},
            <span class="string">"Black"</span>: {<span class="string">"28"</span>: <span class="number">5</span>, <span class="string">"30"</span>: <span class="number">10</span>, <span class="string">"32"</span>: <span class="number">15</span>, <span class="string">"34"</span>: <span class="number">10</span>, <span class="string">"36"</span>: <span class="number">5</span>}
        },
        <span class="string">"rating"</span>: <span class="number">4.3</span>,
        <span class="string">"reviews_count"</span>: <span class="number">180</span>,
        <span class="string">"tags"</span>: [<span class="string">"casual"</span>, <span class="string">"denim"</span>, <span class="string">"slim fit"</span>, <span class="string">"stretch"</span>]
    },
    {
        <span class="string">"product_id"</span>: <span class="string">"P1003"</span>,
        <span class="string">"name"</span>: <span class="string">"Leather Jacket"</span>,
        <span class="string">"category"</span>: <span class="string">"Outerwear > Jackets"</span>,
        <span class="string">"brand"</span>: <span class="string">"LeatherLux"</span>,
        <span class="string">"price"</span>: <span class="number">199.99</span>,
        <span class="string">"description"</span>: <span class="string">"Genuine leather jacket with modern styling. Perfect for adding edge to any outfit."</span>,
        <span class="string">"sizes"</span>: [<span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>],
        <span class="string">"colors"</span>: [<span class="string">"Black"</span>, <span class="string">"Brown"</span>],
        <span class="string">"inventory"</span>: {
            <span class="string">"Black"</span>: {<span class="string">"S"</span>: <span class="number">5</span>, <span class="string">"M"</span>: <span class="number">10</span>, <span class="string">"L"</span>: <span class="number">8</span>, <span class="string">"XL"</span>: <span class="number">5</span>},
            <span class="string">"Brown"</span>: {<span class="string">"S"</span>: <span class="number">3</span>, <span class="string">"M"</span>: <span class="number">7</span>, <span class="string">"L"</span>: <span class="number">5</span>, <span class="string">"XL"</span>: <span class="number">3</span>}
        },
        <span class="string">"rating"</span>: <span class="number">4.7</span>,
        <span class="string">"reviews_count"</span>: <span class="number">95</span>,
        <span class="string">"tags"</span>: [<span class="string">"outerwear"</span>, <span class="string">"leather"</span>, <span class="string">"edgy"</span>, <span class="string">"premium"</span>]
    }
]

<span class="comment"># Mock customer profiles</span>
customer_profiles = {
    <span class="string">"CUST12345"</span>: {
        <span class="string">"name"</span>: <span class="string">"Alex Johnson"</span>,
        <span class="string">"age"</span>: <span class="number">28</span>,
        <span class="string">"gender"</span>: <span class="string">"Male"</span>,
        <span class="string">"preferences"</span>: {
            <span class="string">"style"</span>: <span class="string">"casual"</span>,
            <span class="string">"brands"</span>: [<span class="string">"BasicsCo"</span>, <span class="string">"DenimCo"</span>],
            <span class="string">"colors"</span>: [<span class="string">"Blue"</span>, <span class="string">"Black"</span>, <span class="string">"Gray"</span>],
            <span class="string">"size"</span>: <span class="string">"M"</span>,
            <span class="string">"budget_range"</span>: [<span class="number">20</span>, <span class="number">100</span>]
        },
        <span class="string">"purchase_history"</span>: [
            {<span class="string">"product_id"</span>: <span class="string">"P1001"</span>, <span class="string">"date"</span>: <span class="string">"2023-05-15"</span>, <span class="string">"quantity"</span>: <span class="number">2</span>},
            {<span class="string">"product_id"</span>: <span class="string">"P1002"</span>, <span class="string">"date"</span>: <span class="string">"2023-06-20"</span>, <span class="string">"quantity"</span>: <span class="number">1</span>}
        ]
    },
    <span class="string">"CUST67890"</span>: {
        <span class="string">"name"</span>: <span class="string">"Sarah Williams"</span>,
        <span class="string">"age"</span>: <span class="number">32</span>,
        <span class="string">"gender"</span>: <span class="string">"Female"</span>,
        <span class="string">"preferences"</span>: {
            <span class="string">"style"</span>: <span class="string">"edgy"</span>,
            <span class="string">"brands"</span>: [<span class="string">"LeatherLux"</span>, <span class="string">"DenimCo"</span>],
            <span class="string">"colors"</span>: [<span class="string">"Black"</span>, <span class="string">"Brown"</span>, <span class="string">"Red"</span>],
            <span class="string">"size"</span>: <span class="string">"S"</span>,
            <span class="string">"budget_range"</span>: [<span class="number">50</span>, <span class="number">200</span>]
        },
        <span class="string">"purchase_history"</span>: [
            {<span class="string">"product_id"</span>: <span class="string">"P1003"</span>, <span class="string">"date"</span>: <span class="string">"2023-07-10"</span>, <span class="string">"quantity"</span>: <span class="number">1</span>}
        ]
    }
}

<span class="comment"># Function to get product information</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">get_product_info</span>(product_id: str) -> str:
    <span class="string">"""Get detailed information about a product by ID."""</span>
    <span class="keyword">for</span> product <span class="keyword">in</span> product_catalog:
        <span class="keyword">if</span> product[<span class="string">"product_id"</span>] == product_id:
            <span class="comment"># Format the product information</span>
            info = f<span class="string">"Product: {product['name']}\n"</span>
            info += f<span class="string">"Brand: {product['brand']}\n"</span>
            info += f<span class="string">"Category: {product['category']}\n"</span>
            info += f<span class="string">"Price: ${product['price']:.2f}\n"</span>
            info += f<span class="string">"Description: {product['description']}\n"</span>
            info += f<span class="string">"Sizes: {', '.join(product['sizes'])}\n"</span>
            info += f<span class="string">"Colors: {', '.join(product['colors'])}\n"</span>
            info += f<span class="string">"Rating: {product['rating']}/5 ({product['reviews_count']} reviews)\n"</span>
            info += f<span class="string">"Tags: {', '.join(product['tags'])}"</span>
            <span class="keyword">return</span> info
    
    <span class="keyword">return</span> f<span class="string">"Product with ID {product_id} not found."</span>

<span class="comment"># Function to check product availability</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">check_availability</span>(product_id: str, color: str, size: str) -> str:
    <span class="string">"""Check if a product is available in a specific color and size."""</span>
    <span class="keyword">for</span> product <span class="keyword">in</span> product_catalog:
        <span class="keyword">if</span> product[<span class="string">"product_id"</span>] == product_id:
            <span class="keyword">if</span> color <span class="keyword">in</span> product[<span class="string">"inventory"</span>] <span class="keyword">and</span> size <span class="keyword">in</span> product[<span class="string">"inventory"</span>][color]:
                quantity = product[<span class="string">"inventory"</span>][color][size]
                <span class="keyword">if</span> quantity > <span class="number">0</span>:
                    <span class="keyword">return</span> f<span class="string">"Product {product['name']} in {color} size {size} is available. {quantity} items in stock."</span>
                <span class="keyword">else</span>:
                    <span class="keyword">return</span> f<span class="string">"Product {product['name']} in {color} size {size} is currently out of stock."</span>
            <span class="keyword">else</span>:
                <span class="keyword">return</span> f<span class="string">"Product {product['name']} is not available in {color} size {size}."</span>
    
    <span class="keyword">return</span> f<span class="string">"Product with ID {product_id} not found."</span>

<span class="comment"># Function to get customer profile</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">get_customer_profile</span>(customer_id: str) -> str:
    <span class="string">"""Get customer profile information by ID."""</span>
    <span class="keyword">if</span> customer_id <span class="keyword">in</span> customer_profiles:
        profile = customer_profiles[customer_id]
        
        <span class="comment"># Format the profile information</span>
        info = f<span class="string">"Customer: {profile['name']}, {profile['age']}-year-old {profile['gender']}\n"</span>
        info += f<span class="string">"Style Preference: {profile['preferences']['style']}\n"</span>
        info += f<span class="string">"Preferred Brands: {', '.join(profile['preferences']['brands'])}\n"</span>
        info += f<span class="string">"Preferred Colors: {', '.join(profile['preferences']['colors'])}\n"</span>
        info += f<span class="string">"Size: {profile['preferences']['size']}\n"</span>
        info += f<span class="string">"Budget Range: ${profile['preferences']['budget_range'][0]} - ${profile['preferences']['budget_range'][1]}\n"</span>
        
        <span class="keyword">return</span> info
    
    <span class="keyword">return</span> f<span class="string">"Customer with ID {customer_id} not found."</span>

<span class="comment"># Function to recommend products based on customer preferences</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">recommend_products</span>(customer_id: str, category: str = <span class="string">""</span>, max_price: float = <span class="number">1000</span>) -> str:
    <span class="string">"""Recommend products based on customer preferences."""</span>
    <span class="keyword">if</span> customer_id <span class="keyword">not</span> <span class="keyword">in</span> customer_profiles:
        <span class="keyword">return</span> f<span class="string">"Customer with ID {customer_id} not found."</span>
    
    profile = customer_profiles[customer_id]
    preferences = profile[<span class="string">"preferences"</span>]
    
    <span class="comment"># Filter products based on preferences</span>
    recommendations = []
    
    <span class="keyword">for</span> product <span class="keyword">in</span> product_catalog:
        <span class="comment"># Check if product matches category filter</span>
        <span class="keyword">if</span> category <span class="keyword">and</span> category.lower() <span class="keyword">not</span> <span class="keyword">in</span> product[<span class="string">"category"</span>].lower():
            <span class="keyword">continue</span>
        
        <span class="comment"># Check if product is within budget</span>
        <span class="keyword">if</span> product[<span class="string">"price"</span>] > max_price:
            <span class="keyword">continue</span>
        
        <span class="comment"># Check if product matches customer preferences</span>
        score = <span class="number">0</span>
        
        <span class="comment"># Style match</span>
        <span class="keyword">if</span> preferences[<span class="string">"style"</span>].lower() <span class="keyword">in</span> [tag.lower() <span class="keyword">for</span> tag <span class="keyword">in</span> product[<span class="string">"tags"</span>]]:
            score += <span class="number">3</span>
        
        <span class="comment"># Brand match</span>
        <span class="keyword">if</span> product[<span class="string">"brand"</span>] <span class="keyword">in</span> preferences[<span class="string">"brands"</span>]:
            score += <span class="number">2</span>
        
        <span class="comment"># Color match</span>
        <span class="keyword">for</span> color <span class="keyword">in</span> preferences[<span class="string">"colors"</span>]:
            <span class="keyword">if</span> color.lower() <span class="keyword">in</span> [c.lower() <span class="keyword">for</span> c <span class="keyword">in</span> product[<span class="string">"colors"</span>]]:
                score += <span class="number">1</span>
        
        <span class="comment"># Size availability</span>
        <span class="keyword">if</span> preferences[<span class="string">"size"</span>] <span class="keyword">in</span> product[<span class="string">"sizes"</span>]:
            score += <span class="number">1</span>
        
        <span class="comment"># Price within budget range</span>
        <span class="keyword">if</span> preferences[<span class="string">"budget_range"</span>][<span class="number">0</span>] <= product[<span class="string">"price"</span>] <= preferences[<span class="string">"budget_range"</span>][<span class="number">1</span>]:
            score += <span class="number">1</span>
        
        <span class="comment"># Add to recommendations if score is positive</span>
        <span class="keyword">if</span> score > <span class="number">0</span>:
            recommendations.append({
                <span class="string">"product"</span>: product,
                <span class="string">"score"</span>: score
            })
    
    <span class="comment"># Sort by score and return top recommendations</span>
    recommendations.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">"score"</span>], reverse=<span class="keyword">True</span>)
    
    <span class="keyword">if</span> recommendations:
        result = f<span class="string">"Product Recommendations for {profile['name']}:\n\n"</span>
        
        <span class="keyword">for</span> i, rec <span class="keyword">in</span> enumerate(recommendations[:<span class="number">3</span>], <span class="number">1</span>):  <span class="comment"># Top 3 recommendations</span>
            product = rec[<span class="string">"product"</span>]
            result += f<span class="string">"{i}. {product['name']} - ${product['price']:.2f}\n"</span>
            result += f<span class="string">"   Brand: {product['brand']}\n"</span>
            result += f<span class="string">"   Category: {product['category']}\n"</span>
            result += f<span class="string">"   Description: {product['description']}\n"</span>
            result += f<span class="string">"   Match Score: {rec['score']}/8\n\n"</span>
        
        <span class="keyword">return</span> result
    <span class="keyword">else</span>:
        <span class="keyword">return</span> f<span class="string">"No products found matching {profile['name']}'s preferences."</span>

<span class="comment"># Function to create an outfit</span>
<span class="keyword">@tool</span>
<span class="keyword">def</span> <span class="function">create_outfit</span>(customer_id: str, occasion: str) -> str:
    <span class="string">"""Create a complete outfit recommendation for a specific occasion."""</span>
    <span class="keyword">if</span> customer_id <span class="keyword">not</span> <span class="keyword">in</span> customer_profiles:
        <span class="keyword">return</span> f<span class="string">"Customer with ID {customer_id} not found."</span>
    
    profile = customer_profiles[customer_id]
    preferences = profile[<span class="string">"preferences"</span>]
    
    <span class="comment"># Define outfit components based on occasion</span>
    outfit_components = {
        <span class="string">"casual"</span>: [<span class="string">"Tops > T-Shirts"</span>, <span class="string">"Bottoms > Jeans"</span>],
        <span class="string">"formal"</span>: [<span class="string">"Tops > Dress Shirts"</span>, <span class="string">"Bottoms > Dress Pants"</span>, <span class="string">"Outerwear > Blazers"</span>],
        <span class="string">"party"</span>: [<span class="string">"Tops > Fashion Tops"</span>, <span class="string">"Bottoms > Skirts"</span>, <span class="string">"Outerwear > Jackets"</span>],
        <span class="string">"work"</span>: [<span class="string">"Tops > Blouses"</span>, <span class="string">"Bottoms > Dress Pants"</span>, <span class="string">"Outerwear > Blazers"</span>]
    }
    
    <span class="comment"># Get components for the occasion</span>
    components = outfit_components.get(occasion.lower(), outfit_components[<span class="string">"casual"</span>])
    
    <span class="comment"># Find products for each component</span>
    outfit = {}
    
    <span class="keyword">for</span> component <span class="keyword">in</span> components:
        <span class="keyword">for</span> product <span class="keyword">in</span> product_catalog:
            <span class="keyword">if</span> component <span class="keyword">in</span> product[<span class="string">"category"</span>]:
                <span class="comment"># Check if product matches customer preferences</span>
                <span class="keyword">if</span> (product[<span class="string">"brand"</span>] <span class="keyword">in</span> preferences[<span class="string">"brands"</span>] <span class="keyword">or</span>
                    any(color.lower() <span class="keyword">in</span> [c.lower() <span class="keyword">for</span> c <span class="keyword">in</span> product[<span class="string">"colors"</span>]] <span class="keyword">for</span> color <span class="keyword">in</span> preferences[<span class="string">"colors"</span>]) <span class="keyword">or</span>
                    preferences[<span class="string">"size"</span>] <span class="keyword">in</span> product[<span class="string">"sizes"</span>]):
                    
                    <span class="comment"># Check if product is within budget</span>
                    <span class="keyword">if</span> preferences[<span class="string">"budget_range"</span>][<span class="number">0</span>] <= product[<span class="string">"price"</span>] <= preferences[<span class="string">"budget_range"</span>][<span class="number">1</span>]:
                        outfit[component] = product
                        <span class="keyword">break</span>
    
    <span class="comment"># Format the outfit recommendation</span>
    <span class="keyword">if</span> outfit:
        result = f<span class="string">"Outfit Recommendation for {profile['name']} for {occasion}:\n\n"</span>
        
        <span class="keyword">for</span> component, product <span class="keyword">in</span> outfit.items():
            result += f<span class="string">"- {component.split(' > ')[1]}: {product['name']} (${product['price']:.2f})\n"</span>
            result += f<span class="string">"  {product['description']}\n"</span>
        
        total_price = sum(product[<span class="string">"price"</span>] <span class="keyword">for</span> product <span class="keyword">in</span> outfit.values())
        result += f<span class="string">"\nTotal Price: ${total_price:.2f}"</span>
        
        <span class="keyword">return</span> result
    <span class="keyword">else</span>:
        <span class="keyword">return</span> f<span class="string">"Unable to create an outfit for {occasion} with current inventory."</span>

<span class="comment"># List of tools</span>
tools = [
    get_product_info,
    check_availability,
    get_customer_profile,
    recommend_products,
    create_outfit
]

<span class="comment"># Create a prompt template</span>
prompt = ChatPromptTemplate.from_messages([
    (<span class="string">"system"</span>, <span class="string">"""
    You are a personalized shopping assistant for a fashion retailer. Your goal is to help customers find products that match their style, preferences, and budget.
    
    Always be friendly, helpful, and knowledgeable about fashion. Use the tools available to you to:
    1. Get detailed product information
    2. Check product availability
    3. Access customer profiles to understand preferences
    4. Recommend products based on customer preferences
    5. Create complete outfits for specific occasions
    
    When making recommendations, consider the customer's style preferences, preferred brands, colors, size, and budget range.
    Always check product availability before making recommendations.
    
    Remember to be honest about product limitations and suggest alternatives if the exact item is not available.
    """</span>),
    MessagesPlaceholder(variable_name=<span class="string">"chat_history"</span>),
    (<span class="string">"human"</span>, <span class="string">"{input}"</span>),
    MessagesPlaceholder(variable_name=<span class="string">"agent_scratchpad"</span>),
])

<span class="comment"># Create the agent</span>
agent = create_openai_tools_agent(llm, tools, prompt)

<span class="comment"># Set up memory for conversation history</span>
store = {}

<span class="keyword">def</span> <span class="function">get_session_history</span>(session_id: str) -> BaseChatMessageHistory:
    <span class="keyword">if</span> session_id <span class="keyword">not</span> <span class="keyword">in</span> store:
        store[session_id] = ChatMessageHistory()
    <span class="keyword">return</span> store[session_id]

<span class="comment"># Create the agent executor with memory</span>
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=<span class="keyword">True</span>,
    max_iterations=<span class="number">10</span>,
    early_stopping_method=<span class="string">"generate"</span>
)

<span class="comment"># Wrap with message history</span>
agent_with_history = RunnableWithMessageHistory(
    agent_executor,
    get_session_history,
    input_messages_key=<span class="string">"input"</span>,
    history_messages_key=<span class="string">"chat_history"</span>,
)

<span class="comment"># Function to interact with the shopping assistant</span>
<span class="keyword">def</span> <span class="function">shopping_assistant</span>(input_text, session_id):
    <span class="keyword">return</span> agent_with_history.invoke(
        {<span class="string">"input"</span>: input_text},
        config={<span class="string">"configurable"</span>: {<span class="string">"session_id"</span>: session_id}}
    )[<span class="string">"output"</span>]

<span class="comment"># Example usage</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Create a session for the customer</span>
    session_id = <span class="string">"session_12345"</span>
    
    <span class="comment"># Example 1: Product inquiry</span>
    response1 = shopping_assistant(
        <span class="string">"Can you tell me about product P1001?"</span>,
        session_id
    )
    
    print(<span class="string">"Response 1:"</span>)
    print(response1)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 2: Check availability</span>
    response2 = shopping_assistant(
        <span class="string">"Is the white t-shirt available in size M?"</span>,
        session_id
    )
    
    print(<span class="string">"Response 2:"</span>)
    print(response2)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 3: Customer-specific recommendations</span>
    response3 = shopping_assistant(
        <span class="string">"I'm customer CUST12345. Can you recommend some products for me?"</span>,
        session_id
    )
    
    print(<span class="string">"Response 3:"</span>)
    print(response3)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 4: Create an outfit</span>
    response4 = shopping_assistant(
        <span class="string">"Can you create a casual outfit for me?"</span>,
        session_id
    )
    
    print(<span class="string">"Response 4:"</span>)
    print(response4)
    print(<span class="string">"\n" + <span class="string">"="</span>*<span class="number">50</span> + <span class="string">"\n"</span>)
    
    <span class="comment"># Example 5: Multi-turn conversation</span>
    response5 = shopping_assistant(
        <span class="string">"What about something for a party? I have a budget of $200."</span>,
        session_id
    )
    
    print(<span class="string">"Response 5:"</span>)
    print(response5)</code>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="component-title">
                        <div class="icon">13</div>
                        Callbacks
                    </div>
                    
                    <div class="content-block">
                        <h3><span>✅</span> Business Use Case</h3>
                        <p>
                            In logistics, callbacks enable real-time monitoring and intervention in supply chain operations. For example, a logistics company might use callbacks to track shipments, receive alerts for delays, and automatically trigger alternative routing when disruptions occur, ensuring timely delivery and proactive customer communication.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>❌</span> Problems Solved</h3>
                        <p>
                            Callbacks solve the challenge of monitoring and responding to events in real-time during agent execution. They enable logging, debugging, performance monitoring, and intervention when specific conditions are met, providing visibility and control over complex automated processes.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>⚠️</span> Impact if Absent</h3>
                        <p>
                            Without callbacks, logistics systems would operate without real-time visibility or intervention capabilities, leading to delayed responses to disruptions, inefficient operations, and poor customer service. Issues would only be discovered after they've caused problems, rather than being prevented or mitigated in real-time.
                        </p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔧</span> Predefined or Custom</h3>
                        <p>Custom</p>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🔗</span> Relationship Keyword</h3>
                        <div class="relationship">Control</div>
                    </div>
                    
                    <div class="content-block">
                        <h3><span>🧠</span> In-depth Technical Insight</h3>
                        <p>
                            Callbacks in LangChain are functions that are called at specific points during the execution of chains and agents. They provide hooks for logging, monitoring, and intervention, allowing developers to track performance, debug issues, and implement custom behavior based on execution events.
                        </p>
                        
                        <div class="business-example">
                            <strong>Logistics Implementation:</strong> Implementing shipment monitoring with callbacks:
                        </div>
                        
                        <div class="code-container">
                            <div class="code-header">
                                <div class="code-title">logistics_callbacks.py</div>
                                <div class="code-actions">
                                    <div class="code-action close"></div>
                                    <div class="code-action minimize"></div>
                                    <span class="code-action maximize"></div>
                                </div>
                            </div>
                            <div class="code-block">
<code><span class="comment"># Import necessary modules</span>
<span class="keyword">from</span> langchain_core.callbacks <span class="keyword">import</span> BaseCallbackHandler
<span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage, AIMessage
<span class="keyword">from</span> langchain_core.outputs <span class="keyword">import</span> LLMResult
<span class="keyword">from</span> langchain_core.tools <span class="keyword">import</span> tool
<span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentExecutor, create_openai_tools_agent
<span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate, MessagesPlaceholder
<span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI
<span class="keyword">from</span> typing <span class="keyword">import</span> Any, Dict, List, Optional
<span class="keyword">import</span> json
<span class="keyword">import</span> time
<span class="keyword">import</span> logging
<span class="keyword">import</span> requests
<span class="keyword">import</span> os

<span class="comment"># Set up logging</span>
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

<span class="comment"># Mock shipment data</span>
shipments = {
    <span class="string">"SH12345"</span>: {
        <span class="string">"origin"</span>: <span class="string">"New York, NY"</span>,
        <span class="string">"destination"</span>: <span class="string">"Los Angeles, CA"</span>,
        <span class="string">"status"</span>: <span class="string">"In Transit"</span>,
        <span class="string">"current_location"</span>: <span class="string">"Chicago, IL"</span>,
        <span class="string">"estimated_delivery"</span>: <span class="string">"2023-06-20"</span>,
        <span class="string">"carrier"</span>: <span class="string">"Global Express"</span>,
        <span class="string">"priority"</span>: <span class="string">"High"</span>,
        <span class="string">"weight"</span>: <span class="string">"500 lbs"</span>,
        <span class="string">"dimensions"</span>: <span class="string">"48x40x36 inches"</span>
    },
    <span class="string">"SH67890"</span>: {
        <span class="string">"origin"</span>: <span class="string">"Seattle, WA"</span>,
        <span class="string">"destination"</span>: <span class="string">"Miami, FL"</span>,
        <span class="string">"status"</span>: <span class="string">"Delayed"</span>,
        <span class="string">"current_location"</span>: <span class="string">"Denver, CO"</span>,
        <span class="string">"estimated_delivery"</span>: <span class="string">"2023-06-25"</span>,
        <span class="string">"carrier"</span>: <span class="string">"Freight Masters"</span>,
        <span class="string">"priority"</span>: <span class="string">"Medium"</span>,
        <span class="string">"weight"</span>: <span class="string">"1200 lbs"</span>,
        <span class="string">"dimensions"</span>: <span class="string">"72x48x48 inches"</span>
    }
}

<span class="comment"># Custom callback handler for logistics monitoring</span>
<span class="keyword">class</span> <span class="function">LogisticsCallbackHandler</span>(BaseCallbackHandler):
    <span class="string">"""Callback handler for monitoring logistics operations."""</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="keyword">super</span>().__init__()
        <span class="keyword">self</span>.execution_start_time = <span class="keyword">None</span>
        <span class="keyword">self</span>.current_step = <span class="number">0</span>
        <span class="keyword">self</span>.alerts_triggered = []
    
    <span class="keyword">def</span> <span class="function">on_llm_start</span>(
        <span class="keyword">self</span>, serialized: Dict[str, Any], prompts: List[str], **kwargs: Any
    ) -> Any:
        <span class="string">"""Run when LLM starts running."""</span>
        logger.info(f<span class="string">"LLM started with {len(prompts)} prompts"</span>)
        <span class="keyword">self</span>.execution_start_time = time.time()
    
    <span class="keyword">def</span> <span class="function">on_llm_end</span>(<span class="keyword">self</span>, response: LLMResult, **kwargs: Any) -> Any:
        <span class="string">"""Run when LLM ends running."""</span>
        execution_time = time.time() - <span class="keyword">self</span>.execution_start_time
        logger.info(f<span class="string">"LLM completed in {execution_time:.2f} seconds"</span>)
        
        <span class="comment"># Log token usage</span>
        token_usage = response.llm_output[<span class="string">"token_usage"</span>]
        logger.info(f<span class="string">"Token usage: {token_usage}"</span>)
    
    <span class="keyword">def</span> <span class="function">on_tool_start</span>(
        <span class="keyword">self</span>, serialized: Dict[str, Any], input_str: str, **kwargs: Any
    ) -> Any:
        <span class="string">"""Run when tool starts running."""</span>
        tool_name = serialized.get(<span class="string">"name"</span>, <span class="string">"unknown"</span>)
        <span class="keyword">self</span>.current_step += <span class="number">1</span>
        logger.info(f<span class="string">"Step {self.current_step}: Tool '{tool_name}' started with input: {input_str[:100]}..."</span>)
    
    <span class="keyword">def</span> <span class="function">on_tool_end</span>(
        <span class="keyword">self</span>, output: str, **kwargs: Any
    ) -> Any:
        <span class="string">"""Run when tool ends running."""</span>
        logger.info(f<span class="string">"Tool completed with output: {output[:100]}..."</span>)
        
        <span class="comment"># Check for delays in shipment status</span>
        <span class="keyword">if</span> <span class="string">"delayed"</span> <span class="keyword">in</span> output.lower() <span class="keyword">or</span> <span class="string">"delay"</span> <span class="keyword">in</span> output.lower():
            alert = {
                <span class="string">"type"</span>: <span class="string">"DELAY_DETECTED"</span>,
                <span class="string">"timestamp"</span>: time.time(),
                <span class="string">"message"</span>: <span class="string">"Shipment delay detected in tool output"</span>,
                <span class="string">"details"</span>: output
            }
            <span class="keyword">self</span>.alerts_triggered.append(alert)
            logger.warning(f<span class="string">"ALERT: {alert['message']}"</span>)
    
    <span class="keyword">def</span> <span class="function">on_agent_action</span>(
        <span class="keyword">self</span>, action: Dict[str, Any], **kwargs: Any
    ) -> Any:
        <span class="string">"""Run when agent takes an action."""</span>
        logger.info(f<span class="string">"Agent action: {action['log']}"</span>)
    
    <span class="keyword">def</span> <span class="function">on_agent_finish</span>(
        <span class="keyword">self</span>, finish: Dict[str, Any], **kwargs: Any
    ) -> Any:
        <span class="string">"""Run when agent finishes."""</span>
        logger.info(f<span class="string">"Agent finished with output: {finish['return_values']['output'][:100]}..."</span>)
        
        <span class="comment"># Send summary report</span>
        <span class="keyword">self</span>.send_summary_report(finish[<span class="string">"return_values"</span>][<span class="string">"output"</span>])
    
    <span class="keyword">def</span> <span class="function">send_summary_report</span>(<span class="keyword">self</span>, final_output: str):
        <span class="string">"""Send a summary report of the execution."""</span>
        report = {
            <span class="string">"execution_time"</span>: time.time() - <span class="keyword">self</span>.execution_start_time,
            <span class="string">"steps_executed"</span>: <span class="keyword">self</span>.current_step,
            <span class="string">"alerts_triggered"</span>: <span class="keyword">len</span>(<span class="keyword">self</span>.alerts_triggered),
            <span class="string">"final_output"</span>: final_output[:<span class="number">200</span>] + <span class="string">"..."</span> <span class="keyword">if</span> <span class="keyword">len</span>(final_output) > <span class="number">200</span> <span class="keyword">else</span> final_output
        }
        
        logger.info(f<span class="string">"Execution Summary: {report}"</span>)
        
        <span class="comment"># In a real implementation, this would send to a monitoring system</span>
        <span class="comment"># requests.post("https://monitoring.example.com/api/reports", json=report)</span>

<span class="comment"># Custom callback for real-time alerts</span>
<span class="keyword">class</span> <span class="function">AlertCallbackHandler</span>(BaseCallbackHandler):
    <span class="string">"""Callback handler for sending real-time alerts."""</span>
    
    <span class="keyword">def</span> <span class="function">__init__<
